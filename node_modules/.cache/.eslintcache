[{"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/index.js":"1","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/App.js":"2","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/reportWebVitals.js":"3","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/store.js":"4","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/context/socket.js":"5","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/lobbySlice.js":"6","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/header/Header.js":"7","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/game-list/GameList.js":"8","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/game/Game.js":"9","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/Reel.js":"10","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/SlotGame.js":"11","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/initControls.js":"12","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/ReelsController.js":"13"},{"size":798,"mtime":1715812043142,"results":"14","hashOfConfig":"15"},{"size":651,"mtime":1715812043126,"results":"16","hashOfConfig":"15"},{"size":362,"mtime":1715812043158,"results":"17","hashOfConfig":"15"},{"size":198,"mtime":1715812043158,"results":"18","hashOfConfig":"15"},{"size":1176,"mtime":1715812043130,"results":"19","hashOfConfig":"15"},{"size":476,"mtime":1715812043142,"results":"20","hashOfConfig":"15"},{"size":1945,"mtime":1715812043142,"results":"21","hashOfConfig":"15"},{"size":1183,"mtime":1715812043142,"results":"22","hashOfConfig":"15"},{"size":1510,"mtime":1715812043142,"results":"23","hashOfConfig":"15"},{"size":4398,"mtime":1715812043158,"results":"24","hashOfConfig":"15"},{"size":11737,"mtime":1715812043158,"results":"25","hashOfConfig":"15"},{"size":16803,"mtime":1715812043158,"results":"26","hashOfConfig":"15"},{"size":2333,"mtime":1715812043158,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"13n3098",{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59"},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63"},{"filePath":"64","messages":"65","suppressedMessages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"67","messages":"68","suppressedMessages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/index.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/App.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/reportWebVitals.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/store.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/context/socket.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/lobbySlice.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/header/Header.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/game-list/GameList.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/features/game/Game.js",["71","72"],[],"import { useContext, useEffect, useRef } from 'react';\nimport './Game.scss';\nimport { useNavigate, useParams } from 'react-router-dom';\nimport axios from 'axios';\nimport { SocketContext } from '../../context/socket';\nimport * as PIXI from 'pixi.js';\nimport Reel from '../../slot/Reel';\nimport SlotGame from '../../slot/SlotGame';\nimport initControls from '../../slot/initControls';\nimport gsap from 'gsap';\n\nconst Game = (props) => {\n  const elRef = useRef(null);\n  const params = useParams();\n  const socket = useContext(SocketContext);\n  const navigate = useNavigate();\n\n  useEffect(() => {\n    let game;\n\n    axios.get(`../gamescripts/${params.gameId}.js`).then((response) => {\n      game = (new Function(`\n        const gameId = arguments[0];\n        const Game = arguments[1];\n        const Reel = arguments[2];\n        const initControls = arguments[3];\n        const socket = arguments[4];\n        const PIXI = arguments[5];\n        const gsap = arguments[6];\n        const goToLobby = arguments[7];\n\n        ${response.data}\n      `))(params.gameId, SlotGame, Reel, initControls, socket, PIXI, gsap, () => { navigate('/'); });\n      \n      const gameCanvas = elRef.current.querySelector('canvas');\n      \n      if (gameCanvas) {\n        gameCanvas.remove();\n      }\n\n      elRef.current.appendChild(game.renderer.view);\n    });\n\n    return () => {\n      game.destroy();\n    };\n  }, []);\n\n  return (\n    <div\n      className=\"Game\"\n      ref={elRef}\n    >\n      \n    </div>\n  );\n}\n\nexport default Game;\n","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/Reel.js",["73"],[],"import * as PIXI from 'pixi.js';\nimport anime from 'animejs';\n\nconst Reel = function({\n  positions,\n  spinValues,\n  speed,\n  useBlurredSymbols,\n  bounceDepthPerc,\n  bounceDuration,\n  symbolMargin,\n  maskPaddingX,\n  maskPaddingY,\n}) {\n  this.positions = positions;\n  this.values = [];\n  this._spinValues = spinValues.slice();\n  this.spinValues = spinValues.slice();\n  this.stopValues = [];\n  this.symbols = [];\n  this.container = new PIXI.Container();\n  this.mask = new PIXI.Graphics();\n  this.offset = 0;\n  this.rolling = false;\n  this.stopping = false;\n  this.symbolMargin = symbolMargin;\n  this.speed = speed;\n  this.bounceDepthPerc = bounceDepthPerc;\n  this.bounceDuration = bounceDuration;\n  this.stopFns = [];\n  this.startFns = [];\n  this.maskPaddingX = maskPaddingX || 0;\n  this.maskPaddingY = maskPaddingY || 0;\n  this.useBlurredSymbols = useBlurredSymbols || false;\n\n  this.container.mask = this.mask;\n\n  for (var i = 0; i < positions + 1; i++) {\n    var symbol = new PIXI.Sprite(PIXI.Texture.EMPTY);\n    this.container.addChild(symbol);\n    this.symbols.push(symbol);\n  }\n};\n\nReel.prototype.render = function() {\n  var _this = this;\n\n  var m = _this.mask;\n  m.x = _this.container.x;\n  m.y = _this.container.y;\n  m.clear();\n  m.beginFill(0x000000);\n  m.drawRect(0 - this.maskPaddingX, 0 - this.maskPaddingY, _this.symbols[0].width + (this.maskPaddingX * 2), ((_this.symbols[0].height + this.symbolMargin + this.maskPaddingY) * _this.positions) - this.symbolMargin);\n  m.endFill();\n\n  for (var i = 0; i < _this.symbols.length; i++) {\n    var symbol = _this.symbols[i];\n    symbol.anchor.set(0.5, 0.5);\n    let symbolWidth = 0, symbolHeight = 0;\n\n    if (_this.values[i]) {\n      if (this.rolling) {\n        if (this.useBlurredSymbols) {\n          symbol.texture = PIXI.Texture.from('symbol-' + _this.values[i] + '-blurred');\n        } else {\n          symbol.texture = PIXI.Texture.from('symbol-' + _this.values[i]);\n        }\n      } else {\n        symbol.texture = PIXI.Texture.from('symbol-' + _this.values[i]);\n      }\n\n      symbolWidth = symbol.width;\n      symbolHeight = symbol.height;\n    } else {\n      symbol.texture = PIXI.Texture.EMPTY;\n    }\n\n    if (symbol.hide) {\n      symbol.texture = PIXI.Texture.EMPTY;\n    }\n\n    symbol.x = symbolWidth / 2;\n    symbol.y = ((symbolHeight + this.symbolMargin) * (i - 1)) + (0 + _this.offset);\n    symbol.y += symbolHeight / 2;\n  }\n\n  if (this.rolling) {\n    this.offset += this.symbols[0].height * this.speed;\n\n    if (this.offset >= this.symbols[0].height) {\n      this.offset = 0;\n      if (!isNaN(parseInt(this.stopping))) {\n        this.values.unshift(this.stopValues.pop());\n        this.stopping++;\n      } else {\n        this.values.unshift(this._spinValues.pop());\n\n        if (this._spinValues.length === 0) {\n          this._spinValues = this.spinValues.slice();\n        }\n      }\n      this.values.splice(-1, 1);\n    }\n\n    if (this.stopping == this.positions + 1) {\n      this.rolling = false;\n      this.stopping++;\n      var o = {\n        offset: _this.symbols[0].height * this.bounceDepthPerc,\n      };\n      this.offset = o.offset;\n      anime({\n        targets: o,\n        offset: 0,\n        round: 1,\n        duration: this.bounceDuration,\n        easing: 'easeOutQuint',\n        update: function() {\n          _this.offset = o.offset;\n        },\n        complete: function() {\n          _this.stopping = false;\n          \n          for (let i = 0; i < _this.stopFns.length; i++) {\n            const fn = _this.stopFns[i];\n\n            if (fn.once) {\n              _this.stopFns.splice(i--, 1);\n            }\n\n            fn();\n          }\n        },\n      });\n    }\n  }\n};\n\nReel.prototype.roll = function() {\n  if (!this.rolling && this.stopping === false) {\n    this.rolling = true;\n\n    for (let i = 0; i < this.startFns.length; i++) {\n      const fn = this.startFns[i];\n\n      if (fn.once) {\n        this.startFns.splice(i--, 1);\n      }\n\n      fn();\n    }\n  }\n};\n\nReel.prototype.stop = function() {\n  if (this.rolling && this.stopping === false) {\n    this.stopping = 0;\n  }\n};\n\nReel.prototype.onceStop = function(fn) {\n  fn.once = true;\n  this.stopFns.push(fn);\n};\n\nReel.prototype.onStop = function(fn) {\n  this.stopFns.push(fn);\n};\n\nReel.prototype.onceStart = function(fn) {\n  fn.once = true;\n  this.startFns.push(fn);\n};\n\nReel.prototype.onStart = function(fn) {\n  this.startFns.push(fn);\n};\n\nexport default Reel;","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/SlotGame.js",["74","75"],[],"import * as PIXI from 'pixi.js';\nimport ReelsController from './ReelsController';\nimport gsap from 'gsap';\n\nclass SlotGame {\n  onInitFns = [];\n  onDestroyFns = [];\n  onBalanceChangeFns = [];\n  onBetChangeFns = [];\n  onCoinValueChangeFns = [];\n  onLoadingFns = [];\n  onPlayFns = [];\n\n  constructor({\n    id,\n    width,\n    height,\n    reelsCount,\n    reelPositions,\n    symbolsCount,\n    hasBlurredSymbols,\n    symbolMargin,\n    maskPaddingX,\n    maskPaddingY,\n    reelsSpeed,\n    spinTime,\n    spinTimeBetweenReels,\n  }, socket) {\n    this.id = id;\n    this.width = width;\n    this.height = height;\n    this.reelsCount = reelsCount;\n    this.reelPositions = reelPositions;\n    this.symbolsCount = symbolsCount;\n    this.hasBlurredSymbols = hasBlurredSymbols || false;\n    this.symbolMargin = symbolMargin || 0;\n    this.maskPaddingX = maskPaddingX || 0;\n    this.maskPaddingY = maskPaddingY || 0;\n    this.reelsSpeed = reelsSpeed || 0.18;\n    this.spinTime = spinTime;\n    this.spinTimeBetweenReels = spinTimeBetweenReels;\n    this.socket = socket;\n\n    this.renderer = new PIXI.autoDetectRenderer({\n      width: window.innerWidth,\n      height: window.innerHeight,\n      antialias: true,\n    });\n\n    this.stage = new PIXI.Container();\n\n    this.ticker = new PIXI.Ticker();\n\n    this.ticker.add(() => {\n      this.renderer.render(this.stage);\n    });\n\n    this.assets = [];\n    this.soundAssets = {\n      reelsRun: new Audio(`/data/reels-run.mp3`),\n      reelStop: new Audio(`/data/reel-stop.mp3`),\n      winEffect: new Audio(`/data/win.mp3`),\n      coinsEffect: new Audio(`/data/coins.mp3`),\n    };\n\n    this.sprites = [];\n    this.texts = [];\n\n    this._bet = 1;\n    this.coinValueValues = [0.01, 0.03, 0.10, 0.20, 0.50];\n    this._coinValueValueIndex = 0;\n    this._balance = 0;\n\n    this.autoplay = false;\n    this.creditsTweenCompleted = true;\n  }\n\n  onInit(fn) {\n    this.onInitFns.push(fn);\n  }\n\n  onDestroy(fn) {\n    this.onDestroyFns.push(fn);\n  }\n\n  resize() {\n    const gameRatio = this.width / this.height;\n    const windowRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (windowRatio < gameRatio) {\n      width = window.innerWidth;\n      height = width / gameRatio;\n    } else {\n      height = window.innerHeight;\n      width = height * gameRatio;\n    }\n\n    this.renderer.resize(width, height);\n\n    this.stage.scale.x = this.renderer.view.width / this.width;\n    this.stage.scale.y = this.renderer.view.height / this.height;\n  }\n\n  init() {\n    this.reelsController = new ReelsController(this, this.spinTime, this.spinTimeBetweenReels);\n\n    this.resize();\n\n    this.onInitFns.forEach((fn) => fn());\n\n    this.stage.children.sort(function(a, b) {\n      if (a.z > b.z) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n\n    const onWindowResize = () => {\n      setTimeout(() => {\n        this.resize();\n      }, 50);\n    };\n\n    window.addEventListener('resize', onWindowResize);\n\n    this.onDestroy(() => {\n      window.removeEventListener('resize', onWindowResize);\n    });\n\n    this.onNetworkGamestate = (state) => {\n      this.processGamestate(state);\n    };\n    this.socket.on('gamestate', this.onNetworkGamestate);\n\n    this.onNetworkBet = (data) => {\n      this.processBet(data);\n    };\n    this.socket.on('bet', this.onNetworkBet);\n\n    this.ticker.add(() => {\n      this.texts.forEach((text) => {\n        const t = text.text;\n        text.text = '';\n        text.text = t;\n      });\n    });\n    \n    this.ticker.add(() => {\n      if (this.autoplay) {\n        if (!this.reelsController.reelsActive) {\n          if (this.betResponse === null || !this.betResponse.isWin || this.creditsTweenCompleted) {\n            this.play();\n          }\n        }\n      }\n    });\n\n    this.onActionButtonPressed = (e) => {\n      if (e.code === 'Space' || e.code === 'Numpad0') {\n        this.play();\n      }\n    };\n    window.addEventListener('keypress', this.onActionButtonPressed);\n  }\n\n  start() {\n    PIXI.Assets.addBundle(this.id, this.assets);\n    PIXI.Assets.loadBundle(this.id, (progress) => {\n      this.onLoadingFns.forEach((fn) => {\n        fn(progress);\n      });\n    }).then(() => {\n      this.init();\n\n      this.socket.emit('gamestate', {\n        key: localStorage.getItem('key'),\n        gameId: this.id,\n      });\n    });\n  }\n\n  onLoading(fn) {\n    this.onLoadingFns.push(fn);\n  }\n\n  play() {\n    if (this.reelsController.reelsActive) {\n      if (this.betResponse) {\n        this.reelsController.onStopCommandFns.forEach((fn) => fn());\n  \n        if (this.reelsController.reels.some((r) => (r.rolling == true || r.stopping < r.positions + 1) && !(r.forceStopped || r.stoppedAutomatically))) {\n          this.soundAssets.reelsRun.pause();\n          new Audio(this.soundAssets.reelStop.src).play();\n        }\n\n        this.reelsController.reels.forEach((r, i) => {\n          if ((r.rolling == true || r.stopping < r.positions + 1) && !(r.forceStopped || r.stoppedAutomatically)) {\n            r.values = this.betResponse.reels[i].slice();\n            r.offset = 0;\n            r.stopping = r.positions + 1;\n            r.forceStopped = true;\n          }\n        });\n      }\n\n      if (!this.reelsController.stopCommandGiven) {\n        this.reelsController.stopCommandGiven = true;\n        this.autoplay = false;\n\n        for (let i = 0; i < this.onPlayFns.length; i++) {\n          const fn = this.onPlayFns[i];\n          fn();\n\n          if (fn.once) {\n            this.onPlayFns.splice(i--, 1);\n          }\n        }\n      }\n    } else {\n      this.socket.emit('bet', {\n        key: localStorage.getItem('key'),\n        gameId: this.id,\n        bet: this.bet,\n        coinValue: this.coinValue,\n      });\n\n      this.betResponse = null;\n      this.reelsController.stopCommandGiven = false;\n      this.balance -= Math.round(this.betValue * 100) / 100;\n  \n      this.reelsController.reels.forEach((r) => {\n        r.stoppedAutomatically = false;\n        r.forceStopped = false;\n        r.roll();\n  \n        r.onceStop(() => {\n          if (!this.reelsController.reelsActive) {\n            for (let i = 0; i < this.reelsController.onStopFns.length; i++) {\n              const fn = this.reelsController.onStopFns[i];\n  \n              if (fn.once) {\n                this.reelsController.onStopFns.splice(i--, 1);\n              }\n              \n              fn();\n            }\n          }\n\n          this.soundAssets.reelsRun.pause();\n        });\n      });\n\n      this.soundAssets.reelsRun.loop = true;\n      this.soundAssets.reelsRun.currentTime = 0;\n      this.soundAssets.reelsRun.play();\n  \n      for (let i = 0; i < this.reelsController.onStartFns.length; i++) {\n        const fn = this.reelsController.onStartFns[i];\n  \n        if (fn.once) {\n          this.reelsController.onStartFns.splice(i--, 1);\n        }\n  \n        fn();\n      }\n\n      for (let i = 0; i < this.onPlayFns.length; i++) {\n        const fn = this.onPlayFns[i];\n        fn();\n\n        if (fn.once) {\n          this.onPlayFns.splice(i--, 1);\n        }\n      }\n    }\n  }\n\n  onPlay(fn) {\n    this.onPlayFns.push(fn);\n  }\n\n  oncePlay(fn) {\n    fn.once = true;\n    this.onPlay(fn);\n  }\n\n  processGamestate(state) {\n    this.balance = state.balance;\n    this.coinValueValueIndex = this.coinValueValues.indexOf(state.coinValue);\n    this.bet = state.bet;\n\n    state.reels.forEach((reelValues, i) => {\n      this.reelsController.reels[i].values = reelValues;\n    });\n\n    this.ticker.start();\n  }\n\n  processBet(data) {\n    this.balance = data.balance;\n    \n    data.reels.forEach((reelValues, i) => {\n      this.reelsController.reels[i].stopValues = reelValues.slice();\n    });\n\n    if (data.isWin) {\n      let totalWin = 0;\n      data.win.forEach((line) => totalWin += line.amount);\n      this.balance -= totalWin;\n  \n      const o = { balance: this.balance };\n      this.creditsTweenCompleted = false;\n      this.reelsController.onceStop(() => {\n        const creditsTween = gsap.to(o, {\n          balance: this.balance + totalWin,\n          duration: 3,\n          onUpdate: () => {\n            this.balance = o.balance;\n          },\n          onComplete: () => {\n            this.balance = data.balance;\n            this.creditsTweenCompleted = true;\n          },\n        });\n\n        this.reelsController.onceStart(() => {\n          setTimeout(() => {\n            if (creditsTween && creditsTween.isActive()) {\n              creditsTween.progress(1);\n              creditsTween.kill();\n            }\n          });\n        });\n      });\n    }\n\n    this.betResponse = data;\n\n    if (this.reelsController.stopCommandGiven) {\n      this.play();\n    }\n  }\n\n  addResource(resource) {\n    if (resource.constructor === Array) {\n      this.assets = [\n        ...this.assets,\n        ...resource.map((r) => {\n          return {\n            name: r.name,\n            srcs: r.source,\n          };\n        }),\n      ];\n    } else {\n      this.assets.push({\n        name: resource.name,\n        srcs: resource.source,\n      });\n    }\n  }\n\n  addSprite(resourceKey) {\n    const sprite = PIXI.Sprite.from(resourceKey);\n\n    this.sprites.push(sprite);\n    this.stage.addChild(sprite);\n\n    return sprite;\n  }\n\n  addButton(resources, onClick) {\n    const sprite = PIXI.Sprite.from(resources[0]);\n    sprite.interactive = true;\n\n    sprite.on('pointerenter', () => {\n      if (sprite.disabled) {\n        sprite.texture = PIXI.Texture.from(resources[3]);\n      } else {\n        sprite.texture = PIXI.Texture.from(resources[1]);\n      }\n    });\n\n    let isDown = false;\n    sprite.on('pointerdown', () => {\n      if (sprite.disabled) {\n        sprite.texture = PIXI.Texture.from(resources[3]);\n      } else {\n        sprite.texture = PIXI.Texture.from(resources[2]);\n      }\n      isDown = true;\n    });\n\n    sprite.on('pointerleave', () => {\n      if (sprite.disabled) {\n        sprite.texture = PIXI.Texture.from(resources[3]);\n      } else {\n        sprite.texture = PIXI.Texture.from(resources[0]);\n      }\n    });\n\n    sprite.on('pointerup', () => {\n      if (isDown) {\n        onClick();\n\n        if (sprite.disabled) {\n          sprite.texture = PIXI.Texture.from(resources[3]);\n        } else {\n          sprite.texture = PIXI.Texture.from(resources[0]);\n        }\n        \n        isDown = false;\n      }\n    });\n\n    this.sprites.push(sprite);\n    this.stage.addChild(sprite);\n\n    return sprite;\n  }\n\n  destroy() {\n    this.ticker.stop();\n    this.stage.destroy();\n    this.socket.off('gamestate', this.onNetworkGamestate);\n    this.socket.off('bet', this.onNetworkBet);\n    window.removeEventListener('keypress', this.onActionButtonPressed);\n    this.onDestroyFns.forEach((fn) => fn());\n    PIXI.Assets.unloadBundle(this.id);\n  }\n\n  get coinValue() {\n    return this.coinValueValues[this.coinValueValueIndex];\n  }\n\n  get betValue() {\n    return this.bet * 10 * this.coinValue;\n  }\n\n  get betValueToLocale() {\n    return this.betValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n  }\n\n  set balance(value) {\n    this._balance = value;\n    this.onBalanceChangeFns.forEach((fn) => fn(this._balance));\n  }\n\n  get balance() {\n    return this._balance;\n  }\n\n  onBalanceChange(fn) {\n    this.onBalanceChangeFns.push(fn);\n  }\n\n  set bet(value) {\n    this._bet = value;\n    this.onBetChangeFns.forEach((fn) => fn(this._bet));\n  }\n\n  get bet() {\n    return this._bet;\n  }\n\n  onBetChange(fn) {\n    this.onBetChangeFns.push(fn);\n  }\n\n  set coinValueValueIndex(value) {\n    this._coinValueValueIndex = value;\n    this.onCoinValueChangeFns.forEach((fn) => fn(this.coinValueValues[this._coinValueValueIndex]));\n  }\n\n  get coinValueValueIndex() {\n    return this._coinValueValueIndex;\n  }\n\n  onCoinValueChange(fn) {\n    this.onCoinValueChangeFns.push(fn);\n  }\n}\n\nexport default SlotGame;","/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/initControls.js",[],[],"/home/user/Desktop/Projects/RoyalGames/royalgames-client/src/slot/ReelsController.js",["76","77"],[],"import Reel from './Reel';\n\nclass ReelsController {\n  onStartFns = [];\n  onStopCommandFns = [];\n  onStopFns = [];\n  stopCommandGiven = false;\n\n  constructor(game, spinTime, spinTimeBetweenReels) {\n    this.reels = [];\n\n    for (let i = 0; i < game.reelsCount; i++) {\n      const spinValues = [];\n      for (let k = 0; k < 1000; k++) {\n        spinValues.push(parseInt(Math.random() * game.symbolsCount) + 1);\n      }\n  \n      const reel = new Reel({\n        positions: game.reelPositions,\n        spinValues,\n        speed: game.reelsSpeed,\n        useBlurredSymbols: game.hasBlurredSymbols,\n        bounceDepthPerc: 0.1,\n        bounceDuration: 350,\n        symbolMargin: game.symbolMargin,\n        maskPaddingX: game.maskPaddingX,\n        maskPaddingY: game.maskPaddingY,\n      });\n      reel.container.z = 3;\n      reel.mask.z = 4;\n\n      game.ticker.add(() => {\n        reel.render();\n      });\n\n      game.stage.addChild(reel.container);\n      game.stage.addChild(reel.mask);\n      this.reels.push(reel);\n    }\n  \n    this.reels.forEach((reel) => {\n      reel.rollingTime = 0;\n    });\n\n    this.spinTime = spinTime || 350;\n    this.spinTimeBetweenReels = spinTimeBetweenReels || 200;\n  \n    game.ticker.add((delta) => {\n      for (let i = 0; i < this.reels.length; i++) {\n        const reel = this.reels[i];\n        const active = reel.rolling == true || reel.stopping !== false;\n  \n        if (active && game.betResponse) {\n          const reelStopTime = this.spinTime + (i * this.spinTimeBetweenReels);\n          if (reel.rollingTime > reelStopTime) {\n            reel._stopValues = reel.stopValues;\n            reel.stop();\n            reel.onceStop(function() {\n              reel.stoppedAutomatically = true;\n            });\n          } else {\n            reel.rollingTime += delta * 16.667;\n          }\n        } else {\n          reel.rollingTime = 0;\n        }\n      }\n    });\n  }\n\n  get reelsActive() {\n    return this.reels.some((reel) => reel.rolling == true || reel.stopping !== false);\n  }\n\n  onStart(fn) {\n    this.onStartFns.push(fn);\n  }\n\n  onceStart(fn) {\n    fn.once = true;\n    this.onStart(fn);\n  }\n\n  onStopCommand(fn) {\n    this.onStopCommandFns.push(fn);\n  }\n\n  onStop(fn) {\n    this.onStopFns.push(fn);\n  }\n\n  onceStop(fn) {\n    fn.once = true;\n    this.onStop(fn);\n  }\n}\n\nexport default ReelsController;\n",{"ruleId":"78","severity":1,"message":"79","line":22,"column":15,"nodeType":"80","messageId":"81","endLine":33,"endColumn":9},{"ruleId":"82","severity":1,"message":"83","line":47,"column":6,"nodeType":"84","endLine":47,"endColumn":8,"suggestions":"85"},{"ruleId":"86","severity":1,"message":"87","line":105,"column":23,"nodeType":"88","messageId":"89","endLine":105,"endColumn":25},{"ruleId":"86","severity":1,"message":"87","line":193,"column":63,"nodeType":"88","messageId":"89","endLine":193,"endColumn":65},{"ruleId":"86","severity":1,"message":"87","line":199,"column":26,"nodeType":"88","messageId":"89","endLine":199,"endColumn":28},{"ruleId":"86","severity":1,"message":"87","line":51,"column":37,"nodeType":"88","messageId":"89","endLine":51,"endColumn":39},{"ruleId":"86","severity":1,"message":"87","line":72,"column":51,"nodeType":"88","messageId":"89","endLine":72,"endColumn":53},"no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'navigate', 'params.gameId', and 'socket'. Either include them or remove the dependency array.","ArrayExpression",["90"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",{"desc":"91","fix":"92"},"Update the dependencies array to be: [navigate, params.gameId, socket]",{"range":"93","text":"94"},[1390,1392],"[navigate, params.gameId, socket]"]