{"ast":null,"code":"import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Texture } from '../../shared/texture/Texture.mjs';\nimport { GlTexture } from './GlTexture.mjs';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource.mjs';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource.mjs';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource.mjs';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource.mjs';\nimport { applyStyleParams } from './utils/applyStyleParams.mjs';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat.mjs';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat.mjs';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType.mjs';\nimport './utils/unpremultiplyAlpha.mjs';\n\"use strict\";\nconst BYTES_PER_PIXEL = 4;\nclass GlTextureSystem {\n  constructor(renderer) {\n    this.managedTextures = [];\n    this._glTextures = /* @__PURE__ */Object.create(null);\n    this._glSamplers = /* @__PURE__ */Object.create(null);\n    this._boundTextures = [];\n    this._activeTextureLocation = -1;\n    this._boundSamplers = /* @__PURE__ */Object.create(null);\n    this._uploads = {\n      image: glUploadImageResource,\n      buffer: glUploadBufferImageResource,\n      video: glUploadVideoResource,\n      compressed: glUploadCompressedTextureResource\n    };\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    this._useSeparateSamplers = false;\n    this._renderer = renderer;\n  }\n  contextChange(gl) {\n    this._gl = gl;\n    if (!this._mapFormatToInternalFormat) {\n      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n      this._mapFormatToType = mapFormatToGlType(gl);\n      this._mapFormatToFormat = mapFormatToGlFormat(gl);\n    }\n    this._glTextures = /* @__PURE__ */Object.create(null);\n    this._glSamplers = /* @__PURE__ */Object.create(null);\n    this._boundSamplers = /* @__PURE__ */Object.create(null);\n    for (let i = 0; i < 16; i++) {\n      this.bind(Texture.EMPTY, i);\n    }\n  }\n  initSource(source) {\n    this.bind(source);\n  }\n  bind(texture) {\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const source = texture.source;\n    if (texture) {\n      this.bindSource(source, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(source.style, location);\n      }\n    } else {\n      this.bindSource(null, location);\n      if (this._useSeparateSamplers) {\n        this._bindSampler(null, location);\n      }\n    }\n  }\n  bindSource(source) {\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const gl = this._gl;\n    source._touched = this._renderer.textureGC.count;\n    if (this._boundTextures[location] !== source) {\n      this._boundTextures[location] = source;\n      this._activateLocation(location);\n      source = source || Texture.EMPTY.source;\n      const glTexture = this.getGlSource(source);\n      gl.bindTexture(glTexture.target, glTexture.texture);\n    }\n  }\n  _bindSampler(style) {\n    let location = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const gl = this._gl;\n    if (!style) {\n      this._boundSamplers[location] = null;\n      gl.bindSampler(location, null);\n      return;\n    }\n    const sampler = this._getGlSampler(style);\n    if (this._boundSamplers[location] !== sampler) {\n      this._boundSamplers[location] = sampler;\n      gl.bindSampler(location, sampler);\n    }\n  }\n  unbind(texture) {\n    const source = texture.source;\n    const boundTextures = this._boundTextures;\n    const gl = this._gl;\n    for (let i = 0; i < boundTextures.length; i++) {\n      if (boundTextures[i] === source) {\n        this._activateLocation(i);\n        const glTexture = this.getGlSource(source);\n        gl.bindTexture(glTexture.target, null);\n        boundTextures[i] = null;\n      }\n    }\n  }\n  _activateLocation(location) {\n    if (this._activeTextureLocation !== location) {\n      this._activeTextureLocation = location;\n      this._gl.activeTexture(this._gl.TEXTURE0 + location);\n    }\n  }\n  _initSource(source) {\n    const gl = this._gl;\n    const glTexture = new GlTexture(gl.createTexture());\n    glTexture.type = this._mapFormatToType[source.format];\n    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n    glTexture.format = this._mapFormatToFormat[source.format];\n    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {\n      const biggestDimension = Math.max(source.width, source.height);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    this._glTextures[source.uid] = glTexture;\n    if (!this.managedTextures.includes(source)) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceUpdate, this);\n      source.on(\"styleChange\", this.onStyleChange, this);\n      source.on(\"destroy\", this.onSourceDestroy, this);\n      source.on(\"unload\", this.onSourceUnload, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n      this.managedTextures.push(source);\n    }\n    this.onSourceUpdate(source);\n    this.updateStyle(source, false);\n    return glTexture;\n  }\n  onStyleChange(source) {\n    this.updateStyle(source, false);\n  }\n  updateStyle(source, firstCreation) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    applyStyleParams(source.style, gl, source.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"texParameteri\", gl.TEXTURE_2D,\n    // will force a clamp to edge if the texture is not a power of two\n    !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo, firstCreation);\n  }\n  onSourceUnload(source) {\n    const glTexture = this._glTextures[source.uid];\n    if (!glTexture) return;\n    this.unbind(source);\n    this._glTextures[source.uid] = null;\n    this._gl.deleteTexture(glTexture.texture);\n  }\n  onSourceUpdate(source) {\n    const gl = this._gl;\n    const glTexture = this.getGlSource(source);\n    gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    this._boundTextures[this._activeTextureLocation] = source;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source, false);\n    }\n  }\n  onUpdateMipmaps(source) {\n    let bind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (bind) this.bindSource(source, 0);\n    const glTexture = this.getGlSource(source);\n    this._gl.generateMipmap(glTexture.target);\n  }\n  onSourceDestroy(source) {\n    source.off(\"destroy\", this.onSourceDestroy, this);\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceUpdate, this);\n    source.off(\"unload\", this.onSourceUnload, this);\n    source.off(\"styleChange\", this.onStyleChange, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n    this.onSourceUnload(source);\n  }\n  _initSampler(style) {\n    const gl = this._gl;\n    const glSampler = this._gl.createSampler();\n    this._glSamplers[style._resourceId] = glSampler;\n    applyStyleParams(style, gl, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, \"samplerParameteri\", glSampler, false, true);\n    return this._glSamplers[style._resourceId];\n  }\n  _getGlSampler(sampler) {\n    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGlSource(source) {\n    return this._glTextures[source.uid] || this._initSource(source);\n  }\n  generateCanvas(texture) {\n    const {\n      pixels,\n      width,\n      height\n    } = this.getPixels(texture);\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    if (ctx) {\n      const imageData = ctx.createImageData(width, height);\n      imageData.data.set(pixels);\n      ctx.putImageData(imageData, 0, 0);\n    }\n    return canvas;\n  }\n  getPixels(texture) {\n    const resolution = texture.source.resolution;\n    const frame = texture.frame;\n    const width = Math.max(Math.round(frame.width * resolution), 1);\n    const height = Math.max(Math.round(frame.height * resolution), 1);\n    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n    const renderer = this._renderer;\n    const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n    const gl = renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n    gl.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    if (false) {\n      unpremultiplyAlpha(pixels);\n    }\n    return {\n      pixels: new Uint8ClampedArray(pixels.buffer),\n      width,\n      height\n    };\n  }\n  destroy() {\n    this.managedTextures.slice().forEach(source => this.onSourceDestroy(source));\n    this.managedTextures = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlTextureSystem.extension = {\n  type: [ExtensionType.WebGLSystem],\n  name: \"texture\"\n};\nexport { GlTextureSystem };","map":{"version":3,"names":["BYTES_PER_PIXEL","GlTextureSystem","constructor","renderer","managedTextures","_glTextures","Object","create","_glSamplers","_boundTextures","_activeTextureLocation","_boundSamplers","_uploads","image","glUploadImageResource","buffer","glUploadBufferImageResource","video","glUploadVideoResource","compressed","glUploadCompressedTextureResource","_useSeparateSamplers","_renderer","contextChange","gl","_gl","_mapFormatToInternalFormat","mapFormatToGlInternalFormat","context","extensions","_mapFormatToType","mapFormatToGlType","_mapFormatToFormat","mapFormatToGlFormat","i","bind","Texture","EMPTY","initSource","source","texture","location","arguments","length","undefined","bindSource","_bindSampler","style","_touched","textureGC","count","_activateLocation","glTexture","getGlSource","bindTexture","target","bindSampler","sampler","_getGlSampler","unbind","boundTextures","activeTexture","TEXTURE0","_initSource","GlTexture","createTexture","type","format","internalFormat","autoGenerateMipmaps","supports","nonPowOf2mipmaps","isPowerOfTwo","biggestDimension","Math","max","width","height","mipLevelCount","floor","log2","uid","includes","on","onSourceUpdate","onStyleChange","onSourceDestroy","onSourceUnload","onUpdateMipmaps","push","updateStyle","firstCreation","TEXTURE_2D","applyStyleParams","anisotropicFiltering","nonPowOf2wrapping","deleteTexture","uploadMethodId","upload","webGLVersion","texImage2D","RGBA","pixelWidth","pixelHeight","UNSIGNED_BYTE","generateMipmap","off","splice","indexOf","_initSampler","glSampler","createSampler","_resourceId","generateCanvas","pixels","getPixels","canvas","DOMAdapter","get","createCanvas","ctx","getContext","imageData","createImageData","data","set","putImageData","resolution","frame","round","Uint8Array","renderTarget","getRenderTarget","glRenterTarget","getGpuRenderTarget","bindFramebuffer","FRAMEBUFFER","resolveTargetFramebuffer","readPixels","x","y","unpremultiplyAlpha","Uint8ClampedArray","destroy","slice","forEach","extension","ExtensionType","WebGLSystem","name"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @memberof rendering\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source = source || Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        (this._renderer as null) = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}