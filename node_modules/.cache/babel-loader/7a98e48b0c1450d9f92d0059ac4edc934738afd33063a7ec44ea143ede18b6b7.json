{"ast":null,"code":"\"use strict\";\n\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(\"@group(1) @binding(\".concat(bindingIndex++, \") var textureSource\").concat(i + 1, \": texture_2d<f32>;\"));\n      src.push(\"@group(1) @binding(\".concat(bindingIndex++, \") var textureSampler\").concat(i + 1, \": sampler;\"));\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(\"  default:{\");\n      } else {\n        src.push(\"  case \".concat(i, \":{\"));\n      }\n      src.push(\"      outColor = textureSampleGrad(textureSource\".concat(i + 1, \", textureSampler\").concat(i + 1, \", vUV, uvDx, uvDy);\"));\n      src.push(\"      break;}\");\n    }\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: \"\\n                @in aTextureIdAndRound: vec2<u32>;\\n                @out @interpolate(flat) vTextureId : u32;\\n            \",\n        main: \"\\n                vTextureId = aTextureIdAndRound.y;\\n            \",\n        end: \"\\n                if(aTextureIdAndRound.x == 1)\\n                {\\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\\n                }\\n            \"\n      },\n      fragment: {\n        header: \"\\n                @in @interpolate(flat) vTextureId: u32;\\n    \\n                \".concat(generateBindingSrc(16), \"\\n            \"),\n        main: \"\\n                var uvDx = dpdx(vUV);\\n                var uvDy = dpdy(vUV);\\n    \\n                \".concat(generateSampleSrc(16), \"\\n            \")\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(\"if(vTextureId < \".concat(i, \".5)\"));\n    }\n    src.push(\"{\");\n    src.push(\"\\toutColor = texture(uTextures[\".concat(i, \"], vUV);\"));\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: \"\\n                in vec2 aTextureIdAndRound;\\n                out float vTextureId;\\n              \\n            \",\n        main: \"\\n                vTextureId = aTextureIdAndRound.y;\\n            \",\n        end: \"\\n                if(aTextureIdAndRound.x == 1.)\\n                {\\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n                }\\n            \"\n      },\n      fragment: {\n        header: \"\\n                in float vTextureId;\\n    \\n                uniform sampler2D uTextures[\".concat(maxTextures, \"];\\n              \\n            \"),\n        main: \"\\n    \\n                \".concat(generateSampleGlSrc(16), \"\\n            \")\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\nexport { generateTextureBatchBit, generateTextureBatchBitGl };","map":{"version":3,"names":["textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","push","bindingIndex","i","concat","join","generateSampleSrc","generateTextureBatchBit","name","vertex","header","main","end","fragment","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}