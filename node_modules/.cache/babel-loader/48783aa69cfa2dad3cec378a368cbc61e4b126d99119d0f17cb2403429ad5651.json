{"ast":null,"code":"import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);\n    const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);\n    renderer.encoder.commandEncoder.copyTextureToTexture({\n      texture: baseGpuTexture,\n      origin: originSrc\n    }, {\n      texture: backGpuTexture,\n      origin: originDest\n    }, size);\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget) {\n    let clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let clearColor = arguments.length > 2 ? arguments[2] : undefined;\n    let viewport = arguments.length > 3 ? arguments[3] : undefined;\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map((texture, i) => {\n      var _clearValue;\n      const context = gpuRenderTarget.contexts[i];\n      let view;\n      let resolveTarget;\n      if (context) {\n        const currentTexture = context.getCurrentTexture();\n        const canvasTextureView = currentTexture.createView();\n        view = canvasTextureView;\n      } else {\n        view = this._renderer.texture.getGpuSource(texture).createView({\n          mipLevelCount: 1\n        });\n      }\n      if (gpuRenderTarget.msaaTextures[i]) {\n        resolveTarget = view;\n        view = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i]);\n      }\n      const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n      (_clearValue = clearValue) !== null && _clearValue !== void 0 ? _clearValue : clearValue = renderTargetSystem.defaultClearColor;\n      return {\n        view,\n        resolveTarget,\n        clearValue,\n        storeOp: \"store\",\n        loadOp\n      };\n    });\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget) {\n    let clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let clearColor = arguments.length > 2 ? arguments[2] : undefined;\n    let viewport = arguments.length > 3 ? arguments[3] : undefined;\n    if (!clear) return;\n    const {\n      gpu,\n      encoder\n    } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (CanvasSource.test(colorTexture.resource)) {\n        const context = colorTexture.resource.getContext(\"webgpu\");\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            // eslint-disable-next-line max-len\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach(context => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach(texture => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture === null || msaaTexture === void 0 ? void 0 : msaaTexture.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);\n      });\n    }\n  }\n}\nexport { GpuRenderTargetAdaptor };","map":{"version":3,"names":["GpuRenderTargetAdaptor","init","renderer","renderTargetSystem","_renderer","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","texture","getGpuSource","source","encoder","commandEncoder","copyTextureToTexture","origin","startRenderPass","renderTarget","clear","arguments","length","undefined","clearColor","viewport","gpuRenderTarget","getGpuRenderTarget","descriptor","getDescriptor","pipeline","setRenderTarget","beginRenderPass","setViewport","finishRenderPass","endRenderPass","contexts","getCurrentTexture","colorTextures","clearValue","CLEAR","ALL","NONE","colorAttachments","map","i","_clearValue","context","view","resolveTarget","currentTexture","canvasTextureView","createView","mipLevelCount","msaaTextures","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","depthStencilAttachment","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","gpu","device","standAlone","createCommandEncoder","renderPassDescriptor","passEncoder","x","y","width","height","end","gpuCommands","finish","queue","submit","initGpuRenderTarget","isRoot","GpuRenderTarget","forEach","colorTexture","CanvasSource","test","resource","getContext","alphaMode","transparent","configure","usage","GPUTextureUsage","TEXTURE_BINDING","COPY_DST","RENDER_ATTACHMENT","COPY_SRC","format","e","console","error","antialias","msaaTexture","TextureSource","msaaSamples","destroyGpuRenderTarget","unconfigure","destroy","resizeGpuRenderTarget","resize","_resolution"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts"],"sourcesContent":["import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n"],"mappings":";;;;;AAmBO,MAAMA,sBACb;EAIWC,KAAKC,QAAA,EAA0BC,kBACtC;IACI,KAAKC,SAAY,GAAAF,QAAA;IACjB,KAAKG,mBAAsB,GAAAF,kBAAA;EAAA;EAGxBG,aACHA,CAAAC,0BAAA,EACAC,kBACA,EAAAC,SAAA,EACAC,IAAA,EACAC,UAEJ;IACI,MAAMT,QAAA,GAAW,IAAK,CAAAE,SAAA;IAEtB,MAAMQ,cAAA,GAAiB,IAAK,CAAAC,mBAAA,CACxBN,0BAAA,CACJ;IAEM,MAAAO,cAAA,GAAiBZ,QAAA,CAASa,OAAQ,CAAAC,YAAA,CACpCR,kBAAmB,CAAAS,MAAA,CACvB;IAEAf,QAAA,CAASgB,OAAA,CAAQC,cAAe,CAAAC,oBAAA,CAC5B;MACIL,OAAS,EAAAH,cAAA;MACTS,MAAQ,EAAAZ;IAAA,CACZ,EACA;MACIM,OAAS,EAAAD,cAAA;MACTO,MAAQ,EAAAV;IAAA,CACZ,EACAD,IAAA,CACJ;IAEO,OAAAF,kBAAA;EAAA;EAGJc,eACHA,CAAAC,YAAA,EAKJ;IAAA,IAJIC,KAAuB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;IAAA,IACvBG,UAAA,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IACAE,QAEJ,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACI,MAAMxB,kBAAA,GAAqB,IAAK,CAAAE,mBAAA;IAE1B,MAAAyB,eAAA,GAAkB3B,kBAAmB,CAAA4B,kBAAA,CAAmBR,YAAY;IAE1E,MAAMS,UAAa,QAAKC,aAAc,CAAAV,YAAA,EAAcC,KAAA,EAAOI,UAAU;IAErEE,eAAA,CAAgBE,UAAa,GAAAA,UAAA;IAIxB,KAAA5B,SAAA,CAAU8B,QAAS,CAAAC,eAAA,CAAgBL,eAAe;IAClD,KAAA1B,SAAA,CAAUc,OAAQ,CAAAkB,eAAA,CAAgBN,eAAe;IACjD,KAAA1B,SAAA,CAAUc,OAAQ,CAAAmB,WAAA,CAAYR,QAAQ;EAAA;EAGxCS,gBACPA,CAAA;IACS,KAAAlC,SAAA,CAAUc,OAAA,CAAQqB,aAAc;EAAA;EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;EAQQ1B,oBAAoBU,YAC5B;IACI,MAAMO,eAAkB,QAAKzB,mBAAoB,CAAA0B,kBAAA,CAAmBR,YAAY;IAE5E,IAAAO,eAAA,CAAgBU,QAAS,EAAC,CAC9B;MACI,OAAOV,eAAgB,CAAAU,QAAA,CAAS,CAAC,EAAEC,iBAAkB;IAAA;IAGlD,YAAKrC,SAAA,CAAUW,OAAQ,CAAAC,YAAA,CAC1BO,YAAA,CAAamB,aAAc,EAAC,CAAE,CAAAzB,MAAA,CAClC;EAAA;EAGGgB,cACHV,YACA,EAAAC,KAAA,EACAmB,UAEJ;IACQ,WAAOnB,KAAA,KAAU,SACrB;MACYA,KAAA,GAAAA,KAAA,GAAQoB,KAAM,CAAAC,GAAA,GAAMD,KAAM,CAAAE,IAAA;IAAA;IAGtC,MAAM3C,kBAAA,GAAqB,IAAK,CAAAE,mBAAA;IAE1B,MAAAyB,eAAA,GAAkB3B,kBAAmB,CAAA4B,kBAAA,CAAmBR,YAAY;IAEpE,MAAAwB,gBAAA,GAAmBxB,YAAA,CAAamB,aAAc,CAAAM,GAAA,CAChD,CAACjC,OAAA,EAASkC,CACV;MAAA,IAAAC,WAAA;MACU,MAAAC,OAAA,GAAUrB,eAAgB,CAAAU,QAAA,CAASS,CAAC;MAEtC,IAAAG,IAAA;MACA,IAAAC,aAAA;MAEJ,IAAIF,OACJ;QACU,MAAAG,cAAA,GAAiBH,OAAA,CAAQV,iBAAkB;QAE3C,MAAAc,iBAAA,GAAoBD,cAAA,CAAeE,UAAW;QAE7CJ,IAAA,GAAAG,iBAAA;MAAA,CAGX;QACIH,IAAA,GAAO,KAAKhD,SAAU,CAAAW,OAAA,CAAQC,YAAa,CAAAD,OAAO,EAAEyC,UAAW;UAC3DC,aAAe;QAAA,CAClB;MAAA;MAGD,IAAA3B,eAAA,CAAgB4B,YAAa,CAAAT,CAAC,CAClC;QACoBI,aAAA,GAAAD,IAAA;QACTA,IAAA,QAAKhD,SAAA,CAAUW,OAAQ,CAAA4C,cAAA,CAC1B7B,eAAA,CAAgB4B,YAAA,CAAaT,CAAC,EAClC;MAAA;MAGJ,MAAMW,MAAW,GAAApC,KAAA,GAAkBoB,KAAM,CAAAiB,KAAA,GAAQ,OAAU;MAE3D,CAAAX,WAAA,GAAAP,UAAA,cAAAO,WAAA,cAAAA,WAAA,GAAAP,UAAA,GAAexC,kBAAmB,CAAA2D,iBAAA;MAE3B;QACHV,IAAA;QACAC,aAAA;QACAV,UAAA;QACAoB,OAAS;QACTH;MAAA,CACJ;IAAA,CACJ,CACJ;IAEI,IAAAI,sBAAA;IAIJ,KAAKzC,YAAA,CAAa0C,OAAW,IAAA1C,YAAA,CAAa2C,KAAU,MAAC3C,YAAA,CAAa4C,mBAClE;MACI5C,YAAA,CAAa6C,yBAA0B;MACvC7C,YAAA,CAAa4C,mBAAoB,CAAAlD,MAAA,CAAOoD,WAAc,GAAAvC,eAAA,CAAgBwC,IAAA,GAAO,CAAI;IAAA;IAGrF,IAAI/C,YAAA,CAAa4C,mBACjB;MACI,MAAMI,aAAiB,GAAA/C,KAAA,GAAQoB,KAAM,CAAA4B,OAAA,GAAU,OAAU;MACzD,MAAMC,WAAe,GAAAjD,KAAA,GAAQoB,KAAM,CAAA8B,KAAA,GAAQ,OAAU;MAE5BV,sBAAA;QACrBZ,IAAA,EAAM,KAAKhD,SAAU,CAAAW,OAAA,CAChBC,YAAA,CAAaO,YAAa,CAAA4C,mBAAA,CAAoBlD,MAAM,EACpDuC,UAAW;QAChBmB,cAAgB;QAChBJ,aAAA;QACAK,eAAiB;QACjBH,WAAA;QACAI,YAAc;MAAA,CAClB;IAAA;IAGJ,MAAM7C,UAAsC;MACxCe,gBAAA;MACAiB;IAAA,CACJ;IAEO,OAAAhC,UAAA;EAAA;EAGJR,KAAMA,CAAAD,YAAA,EACb;IAAA,IADyCC,KAAuB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA;IAAA,IAAMG,UAAA,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAwBE,QAC9F,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACI,IAAI,CAACH,KAAA,EAAO;IAEZ,MAAM;MAAEsD,GAAA;MAAK5D;IAAQ,IAAI,IAAK,CAAAd,SAAA;IAE9B,MAAM2E,MAAA,GAASD,GAAI,CAAAC,MAAA;IAEb,MAAAC,UAAA,GAAa9D,OAAA,CAAQC,cAAmB;IAE9C,IAAI6D,UACJ;MACU,MAAA7D,cAAA,GAAiB4D,MAAA,CAAOE,oBAAqB;MACnD,MAAMC,oBAAuB,QAAKjD,aAAc,CAAAV,YAAA,EAAcC,KAAA,EAAOI,UAAU;MAEzE,MAAAuD,WAAA,GAAchE,cAAe,CAAAiB,eAAA,CAAgB8C,oBAAoB;MAE3DC,WAAA,CAAA9C,WAAA,CAAYR,QAAS,CAAAuD,CAAA,EAAGvD,QAAS,CAAAwD,CAAA,EAAGxD,QAAA,CAASyD,KAAO,EAAAzD,QAAA,CAAS0D,MAAQ,KAAG,CAAC;MAErFJ,WAAA,CAAYK,GAAI;MAEV,MAAAC,WAAA,GAActE,cAAA,CAAeuE,MAAO;MAE1CX,MAAA,CAAOY,KAAM,CAAAC,MAAA,CAAO,CAACH,WAAW,CAAC;IAAA,CAGrC;MACI,KAAKnE,eAAgB,CAAAC,YAAA,EAAcC,KAAO,EAAAI,UAAA,EAAYC,QAAQ;IAAA;EAClE;EAGGgE,oBAAoBtE,YAC3B;IAEIA,YAAA,CAAauE,MAAS;IAEhB,MAAAhE,eAAA,GAAkB,IAAIiE,eAAgB;IAI5CxE,YAAA,CAAamB,aAAc,CAAAsD,OAAA,CAAQ,CAACC,YAAA,EAAchD,CAClD;MACI,IAAIiD,YAAa,CAAAC,IAAA,CAAKF,YAAa,CAAAG,QAAQ,CAC3C;QACU,MAAAjD,OAAA,GAAU8C,YAAA,CAAaG,QAAS,CAAAC,UAAA,CAClC,SACJ;QAEM,MAAAC,SAAA,GAAaL,YAA8B,CAAAM,WAAA,GAAc,eAAkB;QAGjF;UACIpD,OAAA,CAAQqD,SAAU;YACdzB,MAAA,EAAQ,IAAK,CAAA3E,SAAA,CAAU0E,GAAI,CAAAC,MAAA;YAAA;YAE3B0B,KAAA,EAAOC,eAAgB,CAAAC,eAAA,GACjBD,eAAA,CAAgBE,QAChB,GAAAF,eAAA,CAAgBG,iBAAA,GAChBH,eAAgB,CAAAI,QAAA;YACtBC,MAAQ;YACRT;UAAA,CACH;QAAA,SAEEU,CACP;UACIC,OAAA,CAAQC,KAAA,CAAMF,CAAC;QAAA;QAGHlF,eAAA,CAAAU,QAAA,CAASS,CAAC,CAAI,GAAAE,OAAA;MAAA;MAGlBrB,eAAA,CAAAwC,IAAA,GAAO2B,YAAA,CAAahF,MAAO,CAAAkG,SAAA;MAEvC,IAAAlB,YAAA,CAAahF,MAAA,CAAOkG,SACxB;QACU,MAAAC,WAAA,GAAc,IAAIC,aAAc;UAClC/B,KAAO;UACPC,MAAQ;UACRlB,WAAa;QAAA,CAChB;QAEevC,eAAA,CAAA4B,YAAA,CAAaT,CAAC,CAAI,GAAAmE,WAAA;MAAA;IACtC,CACH;IAED,IAAItF,eAAA,CAAgBwC,IACpB;MACIxC,eAAA,CAAgBwF,WAAc;MAE9B,IAAI/F,YAAA,CAAa4C,mBACjB;QACiB5C,YAAA,CAAA4C,mBAAA,CAAoBlD,MAAA,CAAOoD,WAAc;MAAA;IAC1D;IAGG,OAAAvC,eAAA;EAAA;EAGJyF,uBAAuBzF,eAC9B;IACoBA,eAAA,CAAAU,QAAA,CAASwD,OAAQ,CAAC7C,OAClC;MACIA,OAAA,CAAQqE,WAAY;IAAA,CACvB;IAEe1F,eAAA,CAAA4B,YAAA,CAAasC,OAAQ,CAACjF,OACtC;MACIA,OAAA,CAAQ0G,OAAQ;IAAA,CACnB;IAED3F,eAAA,CAAgB4B,YAAA,CAAahC,MAAS;IACtCI,eAAA,CAAgBU,QAAA,CAASd,MAAS;EAAA;EAG/B0C,0BAA0B7C,YACjC;IAEI,MAAMO,eAAkB,QAAKzB,mBAAoB,CAAA0B,kBAAA,CAAmBR,YAAY;IAE5E,IAAAA,YAAA,CAAa4C,mBAAuB,IAAArC,eAAA,CAAgBwC,IACxD;MACiB/C,YAAA,CAAA4C,mBAAA,CAAoBlD,MAAA,CAAOoD,WAAc;IAAA;EAC1D;EAGGqD,sBAAsBnG,YAC7B;IACI,MAAMO,eAAkB,QAAKzB,mBAAoB,CAAA0B,kBAAA,CAAmBR,YAAY;IAEhFO,eAAA,CAAgBwD,KAAA,GAAQ/D,YAAa,CAAA+D,KAAA;IACrCxD,eAAA,CAAgByD,MAAA,GAAShE,YAAa,CAAAgE,MAAA;IAEtC,IAAIzD,eAAA,CAAgBwC,IACpB;MACI/C,YAAA,CAAamB,aAAc,CAAAsD,OAAA,CAAQ,CAACC,YAAA,EAAchD,CAClD;QACU,MAAAmE,WAAA,GAActF,eAAgB,CAAA4B,YAAA,CAAaT,CAAC;QAErCmE,WAAA,aAAAA,WAAA,uBAAAA,WAAA,CAAAO,MAAA,CACT1B,YAAA,CAAahF,MAAO,CAAAqE,KAAA,EACpBW,YAAA,CAAahF,MAAO,CAAAsE,MAAA,EACpBU,YAAA,CAAahF,MAAO,CAAA2G,WAAA,CACxB;MAAA,CACH;IAAA;EACL;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}