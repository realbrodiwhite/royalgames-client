{"ast":null,"code":"import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\"use strict\";\nclass RenderGroup {\n  constructor(root) {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this._children = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = {\n      list: [],\n      index: 0\n    };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    this.root = root;\n    this.addChild(root);\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.onChildUpdate(renderGroupChild.root);\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.root.didChange) {\n      this._removeChildFromUpdate(renderGroupChild.root);\n    }\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    if (child !== this.root) {\n      this._children.push(child);\n      child.updateTick = -1;\n      if (child.parent === this.root) {\n        child.relativeRenderGroupDepth = 1;\n      } else {\n        child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n      }\n    }\n    if (child.renderGroup) {\n      if (child.renderGroup.root === child) {\n        this.addRenderGroupChild(child.renderGroup);\n        return;\n      }\n    } else {\n      child.renderGroup = this;\n      child.didChange = true;\n    }\n    if (child._onRender) {\n      if (!child.isRenderGroupRoot) {\n        this.addOnRender(child);\n      } else if (child.renderGroup.root === child) {\n        this.addOnRender(child);\n      }\n    }\n    const children = child.children;\n    if (!child.isRenderGroupRoot) {\n      this.onChildUpdate(child);\n    }\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.isRenderGroupRoot) {\n        this.removeOnRender(child);\n      } else if (child.renderGroup.root === child) {\n        this.removeOnRender(child);\n      }\n    }\n    if (child.renderGroup.root !== child) {\n      const children = child.children;\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      if (child.didChange) {\n        child.renderGroup._removeChildFromUpdate(child);\n      }\n      child.renderGroup = null;\n    } else {\n      this._removeRenderGroupChild(child.renderGroup);\n    }\n    const index = this._children.indexOf(child);\n    if (index > -1) {\n      this._children.splice(index, 1);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7) return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  _removeChildFromUpdate(child) {\n    const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      return;\n    }\n    const index = childrenToUpdate.list.indexOf(child);\n    if (index > -1) {\n      childrenToUpdate.list.splice(index, 1);\n    }\n    childrenToUpdate.index--;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n}\nexport { RenderGroup };","map":{"version":3,"names":["RenderGroup","constructor","root","renderPipeId","canBundle","renderGroupParent","renderGroupChildren","_children","worldTransform","Matrix","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","Object","create","updateTick","childrenRenderablesToUpdate","list","index","structureDidChange","instructionSet","InstructionSet","_onRenderContainers","addChild","localTransform","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","onChildUpdate","push","didChange","_removeChildFromUpdate","indexOf","splice","child","parent","relativeRenderGroupDepth","renderGroup","_onRender","isRenderGroupRoot","addOnRender","children","i","length","removeChild","removeOnRender","updateRenderable","container","globalDisplayStatus","didViewUpdate","renderPipes","onChildViewUpdate","isRenderable","localDisplayStatus","runOnRender"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/container/RenderGroup.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * The render group is the base class for all render groups\n * It is used to render a group of containers together\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    private readonly _children: Container[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    constructor(root: Container)\n    {\n        this.root = root;\n\n        this.addChild(root);\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.onChildUpdate(renderGroupChild.root);\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.root.didChange)\n        {\n            this._removeChildFromUpdate(renderGroupChild.root);\n        }\n\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        // TODO this can be optimized..\n        if (child !== this.root)\n        {\n            this._children.push(child);\n\n            child.updateTick = -1;\n\n            if (child.parent === this.root)\n            {\n                child.relativeRenderGroupDepth = 1;\n            }\n\n            else\n            {\n                child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n            }\n        }\n\n        if (child.renderGroup)\n        {\n            if (child.renderGroup.root === child)\n            {\n                // its already its own render group..\n                this.addRenderGroupChild(child.renderGroup);\n\n                return;\n            }\n        }\n        else\n        {\n            child.renderGroup = this;\n            child.didChange = true;\n        }\n\n        if (child._onRender)\n        {\n            // Add the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group\n\n            if (!child.isRenderGroupRoot)\n            {\n                this.addOnRender(child);\n            }\n            else if (child.renderGroup.root === child)\n            {\n                this.addOnRender(child);\n            }\n        }\n\n        const children = child.children;\n\n        if (!child.isRenderGroupRoot)\n        {\n            this.onChildUpdate(child);\n        }\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group\n\n            if (!child.isRenderGroupRoot)\n            {\n                this.removeOnRender(child);\n            }\n            else if (child.renderGroup.root === child)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        if (child.renderGroup.root !== child)\n        {\n            const children = child.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            if (child.didChange)\n            {\n                child.renderGroup._removeChildFromUpdate(child);\n            }\n\n            child.renderGroup = null;\n        }\n\n        else\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n        }\n\n        const index = this._children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._children.splice(index, 1);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    private _removeChildFromUpdate(child: Container)\n    {\n        const childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        { return; }\n\n        const index = childrenToUpdate.list.indexOf(child);\n\n        // TODO this should be optimized - don't really want to change array size on the fly if we can avoid!\n        if (index > -1)\n        {\n            childrenToUpdate.list.splice(index, 1);\n        }\n\n        childrenToUpdate.index--;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n}\n"],"mappings":";;;AAWO,MAAMA,WACb;EA8BIC,YAAYC,IACZ;IA9BA,KAAOC,YAAe;IACtB,KAAOD,IAAkB;IAEzB,KAAOE,SAAY;IAEnB,KAAOC,iBAAiC;IACxC,KAAOC,mBAAA,GAAqC,EAAC;IAE7C,KAAiBC,SAAA,GAAyB,EAAC;IAEpC,KAAAC,cAAA,GAAyB,IAAIC,MAAO;IAC3C,KAAOC,eAAkB;IACzB,KAAOC,UAAa;IACpB,KAAOC,UAAa;IAGpB;IAAgB,KAAAC,gBAAA,kBAAiFC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAC5G,KAAOC,UAAa;IAGpB;IAAA,KAAgBC,2BAAA,GAAqE;MAAEC,IAAA,EAAM,EAAC;MAAGC,KAAA,EAAO;IAAE;IAG1G;IAAA,KAAOC,kBAAqB;IAErB,KAAAC,cAAA,GAAiC,IAAIC,cAAe;IAE3D,KAAiBC,mBAAA,GAAmC,EAAC;IAIjD,KAAKrB,IAAO,GAAAA,IAAA;IAEZ,KAAKsB,QAAA,CAAStB,IAAI;EAAA;EAGtB,IAAIuB,cACJA,CAAA;IACI,OAAO,KAAKvB,IAAK,CAAAuB,cAAA;EAAA;EAGdC,oBAAoBC,gBAC3B;IACI,IAAIA,gBAAA,CAAiBtB,iBACrB;MACqBsB,gBAAA,CAAAtB,iBAAA,CAAkBuB,uBAAA,CAAwBD,gBAAgB;IAAA;IAG/EA,gBAAA,CAAiBtB,iBAAoB;IAEhC,KAAAwB,aAAA,CAAcF,gBAAA,CAAiBzB,IAAI;IAEnC,KAAAI,mBAAA,CAAoBwB,IAAA,CAAKH,gBAAgB;EAAA;EAG1CC,wBAAwBD,gBAChC;IACQ,IAAAA,gBAAA,CAAiBzB,IAAA,CAAK6B,SAC1B;MACS,KAAAC,sBAAA,CAAuBL,gBAAA,CAAiBzB,IAAI;IAAA;IAGrD,MAAMiB,KAAQ,QAAKb,mBAAoB,CAAA2B,OAAA,CAAQN,gBAAgB;IAE/D,IAAIR,KAAA,GAAQ,CACZ;MACS,KAAAb,mBAAA,CAAoB4B,MAAO,CAAAf,KAAA,EAAO,CAAC;IAAA;IAG5CQ,gBAAA,CAAiBtB,iBAAoB;EAAA;EAGlCmB,SAASW,KAChB;IACI,KAAKf,kBAAqB;IAGtB,IAAAe,KAAA,KAAU,KAAKjC,IACnB;MACS,KAAAK,SAAA,CAAUuB,IAAA,CAAKK,KAAK;MAEzBA,KAAA,CAAMnB,UAAa;MAEf,IAAAmB,KAAA,CAAMC,MAAW,UAAKlC,IAC1B;QACIiC,KAAA,CAAME,wBAA2B;MAAA,CAIrC;QACUF,KAAA,CAAAE,wBAAA,GAA2BF,KAAM,CAAAC,MAAA,CAAOC,wBAA2B;MAAA;IAC7E;IAGJ,IAAIF,KAAA,CAAMG,WACV;MACQ,IAAAH,KAAA,CAAMG,WAAY,CAAApC,IAAA,KAASiC,KAC/B;QAES,KAAAT,mBAAA,CAAoBS,KAAA,CAAMG,WAAW;QAE1C;MAAA;IACJ,CAGJ;MACIH,KAAA,CAAMG,WAAc;MACpBH,KAAA,CAAMJ,SAAY;IAAA;IAGtB,IAAII,KAAA,CAAMI,SACV;MAKQ,KAACJ,KAAA,CAAMK,iBACX;QACI,KAAKC,WAAA,CAAYN,KAAK;MAAA,CAEjB,UAAAA,KAAA,CAAMG,WAAY,CAAApC,IAAA,KAASiC,KACpC;QACI,KAAKM,WAAA,CAAYN,KAAK;MAAA;IAC1B;IAGJ,MAAMO,QAAA,GAAWP,KAAM,CAAAO,QAAA;IAEnB,KAACP,KAAA,CAAMK,iBACX;MACI,KAAKX,aAAA,CAAcM,KAAK;IAAA;IAG5B,SAASQ,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACS,KAAAnB,QAAA,CAASkB,QAAS,CAAAC,CAAC,CAAC;IAAA;EAC7B;EAGGE,YAAYV,KACnB;IAEI,KAAKf,kBAAqB;IAE1B,IAAIe,KAAA,CAAMI,SACV;MAKQ,KAACJ,KAAA,CAAMK,iBACX;QACI,KAAKM,cAAA,CAAeX,KAAK;MAAA,CAEpB,UAAAA,KAAA,CAAMG,WAAY,CAAApC,IAAA,KAASiC,KACpC;QACI,KAAKW,cAAA,CAAeX,KAAK;MAAA;IAC7B;IAGA,IAAAA,KAAA,CAAMG,WAAY,CAAApC,IAAA,KAASiC,KAC/B;MACI,MAAMO,QAAA,GAAWP,KAAM,CAAAO,QAAA;MAEvB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;QACS,KAAAE,WAAA,CAAYH,QAAS,CAAAC,CAAC,CAAC;MAAA;MAGhC,IAAIR,KAAA,CAAMJ,SACV;QACUI,KAAA,CAAAG,WAAA,CAAYN,sBAAA,CAAuBG,KAAK;MAAA;MAGlDA,KAAA,CAAMG,WAAc;IAAA,CAIxB;MACS,KAAAV,uBAAA,CAAwBO,KAAA,CAAMG,WAAW;IAAA;IAGlD,MAAMnB,KAAQ,QAAKZ,SAAU,CAAA0B,OAAA,CAAQE,KAAK;IAE1C,IAAIhB,KAAA,GAAQ,CACZ;MACS,KAAAZ,SAAA,CAAU2B,MAAO,CAAAf,KAAA,EAAO,CAAC;IAAA;EAClC;EAGGU,cAAcM,KACrB;IACI,IAAItB,gBAAmB,QAAKA,gBAAiB,CAAAsB,KAAA,CAAME,wBAAwB;IAE3E,IAAI,CAACxB,gBACL;MACIA,gBAAA,GAAmB,IAAK,CAAAA,gBAAA,CAAiBsB,KAAM,CAAAE,wBAAwB,CAAI;QACvElB,KAAO;QACPD,IAAA,EAAM;MAAC,CACX;IAAA;IAGaL,gBAAA,CAAAK,IAAA,CAAKL,gBAAiB,CAAAM,KAAA,EAAO,CAAI,GAAAgB,KAAA;EAAA;EACtD;EAGOY,iBAAiBC,SACxB;IAEI,IAAIA,SAAA,CAAUC,mBAAsB,MAAO;IAE3CD,SAAA,CAAUE,aAAgB;IAE1B,KAAK7B,cAAA,CAAe8B,WAAY,CAAAH,SAAA,CAAU7C,YAAY,EAAE4C,gBAAA,CAAiBC,SAAS;EAAA;EAG/EI,kBAAkBjB,KACzB;IACI,KAAKlB,2BAA4B,CAAAC,IAAA,CAAK,IAAK,CAAAD,2BAAA,CAA4BE,KAAA,EAAO,CAAI,GAAAgB,KAAA;EAAA;EAG9EH,uBAAuBG,KAC/B;IACI,MAAMtB,gBAAmB,QAAKA,gBAAiB,CAAAsB,KAAA,CAAME,wBAAwB;IAE7E,IAAI,CAACxB,gBACL;MAAE;IAAA;IAEF,MAAMM,KAAQ,GAAAN,gBAAA,CAAiBK,IAAK,CAAAe,OAAA,CAAQE,KAAK;IAGjD,IAAIhB,KAAA,GAAQ,CACZ;MACqBN,gBAAA,CAAAK,IAAA,CAAKgB,MAAO,CAAAf,KAAA,EAAO,CAAC;IAAA;IAGxBN,gBAAA,CAAAM,KAAA;EAAA;EAGrB,IAAIkC,YACJA,CAAA;IACI,OAAQ,IAAK,CAAAnD,IAAA,CAAKoD,kBAAuB,UAAS,KAAK1C,UAAa;EAAA;EACxE;AAAA;AAAA;AAAA;AAAA;EAOO6B,YAAYO,SACnB;IACS,KAAAzB,mBAAA,CAAoBO,IAAA,CAAKkB,SAAS;EAAA;EAGpCF,eAAeE,SACtB;IACI,KAAKzB,mBAAA,CAAoBW,MAAO,MAAKX,mBAAA,CAAoBU,OAAQ,CAAAe,SAAS,GAAG,CAAC;EAAA;EAG3EO,WACPA,CAAA;IACI,SAASZ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI,IAAK,CAAApB,mBAAA,CAAoBqB,MAAA,EAAQD,CACrD;MACS,KAAApB,mBAAA,CAAoBoB,CAAC,EAAEJ,SAAU;IAAA;EAC1C;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}