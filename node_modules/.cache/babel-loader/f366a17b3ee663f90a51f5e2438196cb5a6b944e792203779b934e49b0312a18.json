{"ast":null,"code":"import { BufferResource } from '../../shared/buffer/BufferResource.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\n\"use strict\";\nfunction generateShaderSyncCode(shader, shaderSystem) {\n  const funcFragments = [];\n  const headerFragments = [\"\\n        var g = s.groups;\\n        var sS = r.shader;\\n        var p = s.glProgram;\\n        var ugS = r.uniformGroup;\\n        var resources;\\n    \"];\n  let addedTextreSystem = false;\n  let blockIndex = 0;\n  let textureCount = 0;\n  const programData = shaderSystem._getProgramData(shader.glProgram);\n  for (const i in shader.groups) {\n    const group = shader.groups[i];\n    funcFragments.push(\"\\n            resources = g[\".concat(i, \"].resources;\\n        \"));\n    for (const j in group.resources) {\n      const resource = group.resources[j];\n      if (resource instanceof UniformGroup) {\n        if (resource.ubo) {\n          funcFragments.push(\"\\n                        sS.bindUniformBlock(\\n                            resources[\".concat(j, \"],\\n                            sS._uniformBindMap[\").concat(i, \"[\").concat(j, \"],\\n                            \").concat(blockIndex++, \"\\n                        );\\n                    \"));\n        } else {\n          funcFragments.push(\"\\n                        ugS.updateUniformGroup(resources[\".concat(j, \"], p, sD);\\n                    \"));\n        }\n      } else if (resource instanceof BufferResource) {\n        funcFragments.push(\"\\n                    sS.bindUniformBlock(\\n                        resources[\".concat(j, \"],\\n                        sS._uniformBindMap[\").concat(i, \"[\").concat(j, \"],\\n                        \").concat(blockIndex++, \"\\n                    );\\n                \"));\n      } else if (resource instanceof TextureSource) {\n        const uniformName = shader._uniformBindMap[i][j];\n        const uniformData = programData.uniformData[uniformName];\n        if (uniformData) {\n          if (!addedTextreSystem) {\n            addedTextreSystem = true;\n            headerFragments.push(\"\\n                        var tS = r.texture;\\n                        \");\n          }\n          shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n          funcFragments.push(\"\\n                        tS.bind(resources[\".concat(j, \"], \").concat(textureCount, \");\\n                    \"));\n          textureCount++;\n        }\n      }\n    }\n  }\n  const functionSource = [...headerFragments, ...funcFragments].join(\"\\n\");\n  return new Function(\"r\", \"s\", \"sD\", functionSource);\n}\nexport { generateShaderSyncCode };","map":{"version":3,"names":["generateShaderSyncCode","shader","shaderSystem","funcFragments","headerFragments","addedTextreSystem","blockIndex","textureCount","programData","_getProgramData","glProgram","i","groups","group","push","concat","j","resources","resource","UniformGroup","ubo","BufferResource","TextureSource","uniformName","_uniformBindMap","uniformData","_gl","uniform1i","location","functionSource","join","Function"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts"],"sourcesContent":["import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiantly sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let blockIndex = 0;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            sS._uniformBindMap[${i}[${j}],\n                            ${blockIndex++}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        sS._uniformBindMap[${i}[${j}],\n                        ${blockIndex++}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n"],"mappings":";;;;AAYgB,SAAAA,uBAAuBC,MAAA,EAAgBC,YACvD;EACI,MAAMC,aAAA,GAA0B,EAAC;EAWjC,MAAMC,eAAA,GAA4B,0JAMjC;EAED,IAAIC,iBAAoB;EACxB,IAAIC,UAAa;EACjB,IAAIC,YAAe;EAEnB,MAAMC,WAAc,GAAAN,YAAA,CAAaO,eAAgB,CAAAR,MAAA,CAAOS,SAAS;EAEtD,WAAAC,CAAA,IAAKV,MAAA,CAAOW,MACvB;IACU,MAAAC,KAAA,GAAQZ,MAAO,CAAAW,MAAA,CAAOD,CAAC;IAE7BR,aAAA,CAAcW,IAAK,gCAAAC,MAAA,CACCJ,CAAC,2BACpB;IAEU,WAAAK,CAAA,IAAKH,KAAA,CAAMI,SACtB;MACU,MAAAC,QAAA,GAAWL,KAAM,CAAAI,SAAA,CAAUD,CAAC;MAElC,IAAIE,QAAA,YAAoBC,YACxB;QACI,IAAID,QAAA,CAASE,GACb;UACIjB,aAAA,CAAcW,IAAK,0FAAAC,MAAA,CAECC,CAAC,yDAAAD,MAAA,CACQJ,CAAC,OAAAI,MAAA,CAAIC,CAAC,sCAAAD,MAAA,CACzBT,UAAY,yDAErB;QAAA,CAGL;UACIH,aAAA,CAAcW,IAAK,+DAAAC,MAAA,CACoBC,CAAC,qCACvC;QAAA;MACL,CACJ,UACSE,QAAA,YAAoBG,cAC7B;QACIlB,aAAA,CAAcW,IAAK,kFAAAC,MAAA,CAECC,CAAC,qDAAAD,MAAA,CACQJ,CAAC,OAAAI,MAAA,CAAIC,CAAC,kCAAAD,MAAA,CACzBT,UAAY,iDAErB;MAAA,CACL,UACSY,QAAA,YAAoBI,aAC7B;QACI,MAAMC,WAAc,GAAAtB,MAAA,CAAOuB,eAAgB,CAAAb,CAAsB,EAAEK,CAAsB;QAEnF,MAAAS,WAAA,GAAcjB,WAAY,CAAAiB,WAAA,CAAYF,WAAW;QAEvD,IAAIE,WACJ;UACI,IAAI,CAACpB,iBACL;YACwBA,iBAAA;YACpBD,eAAA,CAAgBU,IAAK,0EAEpB;UAAA;UAGLZ,YAAA,CAAawB,GAAI,CAAAC,SAAA,CAAUF,WAAY,CAAAG,QAAA,EAAUrB,YAAY;UAE7DJ,aAAA,CAAcW,IAAK,gDAAAC,MAAA,CACKC,CAAC,SAAAD,MAAA,CAAMR,YAAY,6BAC1C;UAEDA,YAAA;QAAA;MACJ;IACJ;EACJ;EAGE,MAAAsB,cAAA,GAAiB,CAAC,GAAGzB,eAAA,EAAiB,GAAGD,aAAa,EAAE2B,IAAA,CAAK,IAAI;EAGvE,OAAO,IAAIC,QAAA,CAAS,GAAK,OAAK,MAAMF,cAAc;AACtD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}