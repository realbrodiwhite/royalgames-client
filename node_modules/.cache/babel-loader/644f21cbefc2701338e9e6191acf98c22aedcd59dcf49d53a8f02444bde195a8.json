{"ast":null,"code":"import { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { CLEAR } from '../const.mjs';\nimport { GlRenderTarget } from '../GlRenderTarget.mjs';\n\"use strict\";\nclass GlRenderTargetAdaptor {\n  constructor() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n    renderer.runners.contextChange.add(this);\n  }\n  contextChange() {\n    this._clearColorCache = [0, 0, 0, 0];\n    this._viewPortCache = new Rectangle();\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const renderer = this._renderer;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n    const gl = renderer.gl;\n    this.finishRenderPass(sourceRenderSurfaceTexture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    renderer.texture.bind(destinationTexture, 0);\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget) {\n    let clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let clearColor = arguments.length > 2 ? arguments[2] : undefined;\n    let viewport = arguments.length > 3 ? arguments[3] : undefined;\n    const renderTargetSystem = this._renderTargetSystem;\n    const source = renderTarget.colorTexture;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    let viewPortY = viewport.y;\n    if (renderTarget.isRoot) {\n      viewPortY = source.pixelHeight - viewport.height;\n    }\n    renderTarget.colorTextures.forEach(texture => {\n      this._renderer.texture.unbind(texture);\n    });\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n    const viewPortCache = this._viewPortCache;\n    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {\n      viewPortCache.x = viewport.x;\n      viewPortCache.y = viewPortY;\n      viewPortCache.width = viewport.width;\n      viewPortCache.height = viewport.height;\n      gl.viewport(viewport.x, viewPortY, viewport.width, viewport.height);\n    }\n    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {\n      this._initStencil(gpuRenderTarget);\n    }\n    this.clear(renderTarget, clear, clearColor);\n  }\n  finishRenderPass(renderTarget) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (!glRenderTarget.msaa) return;\n    const gl = this._renderer.gl;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n    gl.blitFramebuffer(0, 0, glRenderTarget.width, glRenderTarget.height, 0, 0, glRenderTarget.width, glRenderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n  }\n  initGpuRenderTarget(renderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const glRenderTarget = new GlRenderTarget();\n    if (renderTarget.colorTexture.resource === renderer.gl.canvas) {\n      glRenderTarget.framebuffer = null;\n      return glRenderTarget;\n    }\n    this._initColor(renderTarget, glRenderTarget);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return glRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    const gl = this._renderer.gl;\n    if (gpuRenderTarget.framebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n      gpuRenderTarget.framebuffer = null;\n    }\n    if (gpuRenderTarget.resolveTargetFramebuffer) {\n      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n      gpuRenderTarget.resolveTargetFramebuffer = null;\n    }\n    if (gpuRenderTarget.depthStencilRenderBuffer) {\n      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n      gpuRenderTarget.depthStencilRenderBuffer = null;\n    }\n    gpuRenderTarget.msaaRenderBuffer.forEach(renderBuffer => {\n      gl.deleteRenderbuffer(renderBuffer);\n    });\n    gpuRenderTarget.msaaRenderBuffer = null;\n  }\n  clear(_renderTarget, clear, clearColor) {\n    if (!clear) return;\n    const renderTargetSystem = this._renderTargetSystem;\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const gl = this._renderer.gl;\n    if (clear & CLEAR.COLOR) {\n      var _clearColor;\n      (_clearColor = clearColor) !== null && _clearColor !== void 0 ? _clearColor : clearColor = renderTargetSystem.defaultClearColor;\n      const clearColorCache = this._clearColorCache;\n      const clearColorArray = clearColor;\n      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {\n        clearColorCache[0] = clearColorArray[0];\n        clearColorCache[1] = clearColorArray[1];\n        clearColorCache[2] = clearColorArray[2];\n        clearColorCache[3] = clearColorArray[3];\n        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n      }\n    }\n    gl.clear(clear);\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    if (renderTarget.isRoot) return;\n    const renderTargetSystem = this._renderTargetSystem;\n    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    this._resizeColor(renderTarget, glRenderTarget);\n    if (renderTarget.stencil) {\n      this._resizeStencil(glRenderTarget);\n    }\n  }\n  _initColor(renderTarget, glRenderTarget) {\n    const renderer = this._renderer;\n    const gl = renderer.gl;\n    const resolveTargetFramebuffer = gl.createFramebuffer();\n    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      const source = colorTexture.source;\n      if (source.antialias) {\n        if (renderer.context.supports.msaa) {\n          glRenderTarget.msaa = true;\n        } else {\n          warn(\"[RenderTexture] Antialiasing on textures is not supported in WebGL1\");\n        }\n      }\n      renderer.texture.bindSource(source, 0);\n      const glSource = renderer.texture.getGlSource(source);\n      const glTexture = glSource.texture;\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, 3553,\n      // texture.target,\n      glTexture, 0);\n    });\n    if (glRenderTarget.msaa) {\n      const viewFramebuffer = gl.createFramebuffer();\n      glRenderTarget.framebuffer = viewFramebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((_, i) => {\n        const msaaRenderBuffer = gl.createRenderbuffer();\n        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n      });\n    } else {\n      glRenderTarget.framebuffer = resolveTargetFramebuffer;\n    }\n    this._resizeColor(renderTarget, glRenderTarget);\n  }\n  _resizeColor(renderTarget, glRenderTarget) {\n    const source = renderTarget.colorTexture.source;\n    glRenderTarget.width = source.pixelWidth;\n    glRenderTarget.height = source.pixelHeight;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (i === 0) return;\n      colorTexture.source.resize(source.width, source.height, source._resolution);\n    });\n    if (glRenderTarget.msaa) {\n      const renderer = this._renderer;\n      const gl = renderer.gl;\n      const viewFramebuffer = glRenderTarget.framebuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const source2 = colorTexture.source;\n        renderer.texture.bindSource(source2, 0);\n        const glSource = renderer.texture.getGlSource(source2);\n        const glInternalFormat = glSource.internalFormat;\n        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n        gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);\n        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, source2.pixelWidth, source2.pixelHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderBuffer);\n      });\n    }\n  }\n  _initStencil(glRenderTarget) {\n    if (glRenderTarget.framebuffer === null) return;\n    const gl = this._renderer.gl;\n    const depthStencilRenderBuffer = gl.createRenderbuffer();\n    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);\n    this._resizeStencil(glRenderTarget);\n  }\n  _resizeStencil(glRenderTarget) {\n    const gl = this._renderer.gl;\n    gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);\n    if (glRenderTarget.msaa) {\n      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height);\n    } else {\n      gl.renderbufferStorage(gl.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);\n    }\n  }\n}\nexport { GlRenderTargetAdaptor };","map":{"version":3,"names":["GlRenderTargetAdaptor","constructor","_clearColorCache","_viewPortCache","Rectangle","init","renderer","renderTargetSystem","_renderer","_renderTargetSystem","runners","contextChange","add","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","glRenderTarget","getGpuRenderTarget","gl","finishRenderPass","bindFramebuffer","FRAMEBUFFER","resolveTargetFramebuffer","texture","bind","copyTexSubImage2D","TEXTURE_2D","x","y","width","height","startRenderPass","renderTarget","clear","arguments","length","undefined","clearColor","viewport","source","colorTexture","gpuRenderTarget","viewPortY","isRoot","pixelHeight","colorTextures","forEach","unbind","framebuffer","viewPortCache","depthStencilRenderBuffer","stencil","depth","_initStencil","msaa","READ_FRAMEBUFFER","blitFramebuffer","COLOR_BUFFER_BIT","NEAREST","initGpuRenderTarget","GlRenderTarget","resource","canvas","_initColor","destroyGpuRenderTarget","deleteFramebuffer","deleteRenderbuffer","msaaRenderBuffer","renderBuffer","_renderTarget","CLEAR","ALL","NONE","COLOR","_clearColor","defaultClearColor","clearColorCache","clearColorArray","resizeGpuRenderTarget","_resizeColor","_resizeStencil","createFramebuffer","pixelWidth","i","antialias","context","supports","warn","bindSource","glSource","getGlSource","glTexture","framebufferTexture2D","COLOR_ATTACHMENT0","viewFramebuffer","_","createRenderbuffer","resize","_resolution","source2","glInternalFormat","internalFormat","bindRenderbuffer","RENDERBUFFER","renderbufferStorageMultisample","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","DEPTH24_STENCIL8","renderbufferStorage","webGLVersion","DEPTH_STENCIL"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts"],"sourcesContent":["import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @memberof rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        if (renderTarget.colorTexture.resource === renderer.gl.canvas)\n        {\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}