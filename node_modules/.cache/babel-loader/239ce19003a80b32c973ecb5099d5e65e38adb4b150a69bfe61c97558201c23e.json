{"ast":null,"code":"import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(\"Could not find a source type for resource: \".concat(opts.resource));\n}\nfunction resourceToTexture() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let skipCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({\n    source: autoDetectSource(opts)\n  });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id) {\n  let skipCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({\n      source: id\n    });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nexport { autoDetectSource, resourceToTexture, textureFrom };","map":{"version":3,"names":["sources","extensions","handleByList","ExtensionType","TextureSource","autoDetectSource","options","arguments","length","undefined","hasResource","resource","res","opts","i","Source","test","Error","concat","resourceToTexture","skipCache","Cache","has","get","texture","Texture","source","on","remove","set","textureFrom","id","from"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n"],"mappings":";;;;;AAiBA,MAAMA,OAAA,GAAsC,EAAC;AAE7CC,UAAW,CAAAC,YAAA,CAAaC,aAAc,CAAAC,aAAA,EAAeJ,OAAO;AAO5C,SAAAK,iBAAA,EAChB;EAAA,IADiCC,OAAoC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,QACrE;EACU,MAAAG,WAAA,GAAcJ,OAAA,IAAYA,OAAiC,CAAAK,QAAA;EAC3D,MAAAC,GAAA,GAAMF,WAAe,GAAAJ,OAAA,CAAiCK,QAAW,GAAAL,OAAA;EACvE,MAAMO,IAAO,GAAAH,WAAA,GAAcJ,OAAkC;IAAEK,QAAA,EAAUL;EAAQ;EAEjF,SAASQ,CAAI,MAAGA,CAAI,GAAAd,OAAA,CAAQQ,MAAA,EAAQM,CACpC;IACU,MAAAC,MAAA,GAASf,OAAA,CAAQc,CAAC;IAEpB,IAAAC,MAAA,CAAOC,IAAK,CAAAJ,GAAG,CACnB;MACW,WAAIG,MAAA,CAAOF,IAAI;IAAA;EAC1B;EAGJ,MAAM,IAAII,KAAA,+CAAAC,MAAA,CAAoDL,IAAA,CAAKF,QAAQ,CAAE;AACjF;AAEO,SAASQ,iBACZA,CAAA,EAGJ;EAAA,IAHIb,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoC,EAAC;EAAA,IACrCa,SAAA,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY,KAEhB;EACU,MAAAG,WAAA,GAAcJ,OAAA,IAAYA,OAAiC,CAAAK,QAAA;EAC3D,MAAAA,QAAA,GAAWD,WAAe,GAAAJ,OAAA,CAAiCK,QAAW,GAAAL,OAAA;EAC5E,MAAMO,IAAO,GAAAH,WAAA,GAAcJ,OAAkC;IAAEK,QAAA,EAAUL;EAAQ;EAEjF,IAAI,CAACc,SAAA,IAAaC,KAAM,CAAAC,GAAA,CAAIX,QAAQ,CACpC;IACW,OAAAU,KAAA,CAAME,GAAA,CAAIZ,QAAQ;EAAA;EAGvB,MAAAa,OAAA,GAAU,IAAIC,OAAQ;IAAEC,MAAA,EAAQrB,gBAAiB,CAAAQ,IAAI;EAAA,CAAG;EAEtDW,OAAA,CAAAG,EAAA,CAAG,WAAW,MACtB;IACQ,IAAAN,KAAA,CAAMC,GAAI,CAAAX,QAAQ,CACtB;MACIU,KAAA,CAAMO,MAAA,CAAOjB,QAAQ;IAAA;EACzB,CACH;EAED,IAAI,CAACS,SACL;IACUC,KAAA,CAAAQ,GAAA,CAAIlB,QAAA,EAAUa,OAAO;EAAA;EAGxB,OAAAA,OAAA;AACX;AASgB,SAAAM,YAAYC,EAAuB,EACnD;EAAA,IADmDX,SAAA,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY,KAC/D;EACQ,WAAOwB,EAAA,KAAO,QAClB;IACW,OAAAV,KAAA,CAAME,GAAA,CAAIQ,EAAE;EAAA,CACvB,UACSA,EAAA,YAAc3B,aACvB;IACI,OAAO,IAAIqB,OAAA,CAAQ;MAAEC,MAAA,EAAQK;IAAA,CAAI;EAAA;EAI9B,OAAAZ,iBAAA,CAAkBY,EAAA,EAAIX,SAAS;AAC1C;AAEAK,OAAA,CAAQO,IAAO,GAAAF,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}