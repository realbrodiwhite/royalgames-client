{"ast":null,"code":"\"use strict\";\n\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: /* wgsl */\"\\n            struct LocalUniforms {\\n                uColor:vec4<f32>,\\n                uTransformMatrix:mat3x3<f32>,\\n                uDistance: f32,\\n                uRound:f32,\\n            }\\n\\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\\n        \",\n    main: /* wgsl */\"\\n            vColor *= localUniforms.uColor;\\n            modelMatrix *= localUniforms.uTransformMatrix;\\n        \",\n    end: /* wgsl */\"\\n            if(localUniforms.uRound == 1)\\n            {\\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\\n            }\\n        \"\n  },\n  fragment: {\n    header: /* wgsl */\"\\n            struct LocalUniforms {\\n                uColor:vec4<f32>,\\n                uTransformMatrix:mat3x3<f32>,\\n                uDistance: f32\\n            }\\n\\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\\n         \",\n    main: /* wgsl */\" \\n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\\n        \"\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: /* glsl */\"\\n            uniform mat3 uTransformMatrix;\\n            uniform vec4 uColor;\\n            uniform float uRound;\\n        \",\n    main: /* glsl */\"\\n            vColor *= uColor;\\n            modelMatrix *= uTransformMatrix;\\n        \",\n    end: /* glsl */\"\\n            if(uRound == 1.)\\n            {\\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n            }\\n        \"\n  },\n  fragment: {\n    header: /* glsl */\"\\n            uniform float uDistance;\\n         \",\n    main: /* glsl */\" \\n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\\n        \"\n  }\n};\nexport { localUniformMSDFBit, localUniformMSDFBitGl };","map":{"version":3,"names":["localUniformMSDFBit","name","vertex","header","main","end","fragment","localUniformMSDFBitGl"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts"],"sourcesContent":["// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n"],"mappings":";;AAGO,MAAMA,mBAAsB;EAC/BC,IAAM;EACNC,MAAQ;IACJC,MAAA,4SAAkB;IAUlBC,IAAA,iIAAgB;IAIhBC,GAAA;EAAe,CAMnB;EACAC,QAAU;IACNH,MAAA,+QAAkB;IASlBC,IAAA;EAAgB;AAKxB;AAEO,MAAMG,qBAAwB;EACjCN,IAAM;EACNC,MAAQ;IACJC,MAAA,yIAAkB;IAKlBC,IAAA,qGAAgB;IAIhBC,GAAA;EAAe,CAMnB;EACAC,QAAU;IACNH,MAAA,+DAAkB;IAGlBC,IAAA;EAAgB;AAKxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}