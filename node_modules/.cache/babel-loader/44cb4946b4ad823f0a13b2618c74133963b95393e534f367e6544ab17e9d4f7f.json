{"ast":null,"code":"\"use strict\";\n\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return {\n      len,\n      nx,\n      ny\n    };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    var _p2$radius;\n    const p2 = points[i % points.length];\n    const pRadius = (_p2$radius = p2.radius) !== null && _p2$radius !== void 0 ? _p2$radius : radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(Math.cos(halfAngle) * pRadius / Math.sin(halfAngle));\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(cX + Math.cos(startAngle) * cRadius, cY + Math.sin(startAngle) * cRadius);\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    var _thisPoint$radius;\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = (_thisPoint$radius = thisPoint.radius) !== null && _thisPoint$radius !== void 0 ? _thisPoint$radius : radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(thisPoint, lastPoint, lastOffsetDistance / lastEdgeLength);\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\nexport { roundedShapeArc, roundedShapeQuadraticCurve };","map":{"version":3,"names":["roundedShapeArc","g","points","radius","vecFrom","p","pp","x","y","len","Math","sqrt","nx","ny","sharpCorner","i","moveTo","lineTo","p1","length","_p2$radius","p2","pRadius","p3","v1","v2","angle","asin","radDirection","drawDirection","PI","halfAngle","cRadius","lenOut","abs","cos","sin","min","cX","cY","startAngle","atan2","endAngle","arc","roundedShapeQuadraticCurve","smoothness","distance","pointLerp","t","numPoints","_thisPoint$radius","thisPoint","lastPoint","nextPoint","lastEdgeLength","start","lastOffsetDistance","nextEdgeLength","end","nextOffsetDistance","quadraticCurveTo"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts"],"sourcesContent":["import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}