{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { EventsTicker } from './EventTicker.mjs';\nimport { FederatedMouseEvent } from './FederatedMouseEvent.mjs';\nimport { FederatedPointerEvent } from './FederatedPointerEvent.mjs';\nimport { FederatedWheelEvent } from './FederatedWheelEvent.mjs';\n\"use strict\";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new EventEmitter();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      warn(\"[EventBoundary]: Event mapping not defined for \".concat(e.type));\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n    const invertedPath = this[fn](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn);\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type) {\n    let targets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._allInteractiveElements;\n    if (targets.length === 0) return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach(event => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++) {\n      if (!target.parent) {\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    let ignore = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget)) return null;\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location));\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive) this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0) this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0) return null;\n    if (shouldReturn) return this._hitElements;\n    if (isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, relativeLocation, testFn, pruneFn);\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable) {\n      return true;\n    }\n    if (container.eventMode === \"none\") {\n      return true;\n    }\n    if (container.eventMode === \"passive\" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._mask} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container !== null && container !== void 0 && container.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    var _type, _e$currentTarget$hand, _e$currentTarget;\n    type = (_type = type) !== null && _type !== void 0 ? _type : e.type;\n    const handlerKey = \"on\".concat(type);\n    (_e$currentTarget$hand = (_e$currentTarget = e.currentTarget)[handlerKey]) === null || _e$currentTarget$hand === void 0 ? void 0 : _e$currentTarget$hand.call(_e$currentTarget, e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? \"\".concat(type, \"capture\") : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerdown\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchstart\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    var _trackingData$overTar, _this$enableGlobalMov;\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (((_trackingData$overTar = trackingData.overTargets) === null || _trackingData$overTar === void 0 ? void 0 : _trackingData$overTar.length) > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, \"pointerout\");\n      if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\");\n      if (isMouse) this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget === null || outTarget === void 0 ? void 0 : outTarget.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target) break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = (_this$enableGlobalMov = this.enableGlobalMoveEvents) !== null && _this$enableGlobalMov !== void 0 ? _this$enableGlobalMov : true;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n    allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n    if (e.pointerType === \"touch\") {\n      this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n      allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n    }\n    if (isMouse) {\n      var _e$target;\n      this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n      allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n      this.cursor = (_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    var _e$target2;\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\");\n    if (isMouse) this.dispatchEvent(e, \"mouseover\");\n    if (e.pointerType === \"mouse\") this.cursor = (_e$target2 = e.target) === null || _e$target2 === void 0 ? void 0 : _e$target2.cursor;\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse) this.notifyTarget(enterEvent, \"mouseenter\");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse) this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse) this.notifyTarget(leaveEvent, \"mouseleave\");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerup\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchend\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else if (clickEvent.pointerType === \"touch\") {\n        this.dispatchEvent(clickEvent, \"tap\");\n      }\n      this.dispatchEvent(clickEvent, \"pointertap\");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent)) {\n      warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent)) {\n      warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    var _ref;\n    const event = this.allocateEvent(FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = (_ref = target !== null && target !== void 0 ? target : this.hitTest(event.global.x, event.global.y)) !== null && _ref !== void 0 ? _ref : this._hitElements[0];\n    if (typeof type === \"string\") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type !== null && type !== void 0 ? type : event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this) throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners) return;\n    if (!e.currentTarget.isInteractive()) return;\n    if (\"fn\" in listeners) {\n      if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\nexport { EventBoundary };","map":{"version":3,"names":["PROPAGATION_LIMIT","tempHitLocation","Point","tempLocalMapping","EventBoundary","constructor","rootTarget","dispatch","EventEmitter","moveOnAll","enableGlobalMoveEvents","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","bind","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","type","fn","push","priority","sort","a","b","dispatchEvent","e","propagationStopped","propagationImmediatelyStopped","propagate","emit","mapEvent","mappers","i","j","length","warn","concat","hitTest","x","y","EventsTicker","pauseUpdate","useMove","invertedPath","eventMode","set","target","composedPath","eventPhase","CAPTURING_PHASE","currentTarget","notifyTarget","AT_TARGET","BUBBLING_PHASE","all","targets","arguments","undefined","events","Array","isArray","forEach","event","propagationPath","parent","Error","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","children","child","nestedHit","_isInteractive","isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","relativeLocation","int","container","visible","renderable","hitArea","worldTransform","applyInverse","contains","effects","effect","containsPoint","effectContainsPoint","_type","_e$currentTarget$hand","_e$currentTarget","handlerKey","call","key","_notifyListeners","from","FederatedPointerEvent","createPointerEvent","pointerType","isRightButton","button","pointerId","pressTargetsByButton","freeEvent","_trackingData$overTar","_this$enableGlobalMov","isMouse","outTarget","findMountedTarget","overTargets","outType","outEvent","includes","leaveEvent","overType","overEvent","clonePointerEvent","overTargetAncestor","didPointerEnter","enterEvent","allMethods","allowGlobalPointerEvents","splice","_e$target","cursor","_e$target2","now","performance","pressTarget","clickTarget","clickEvent","path","clicksByButton","clickCount","timeStamp","clickHistory","detail","FederatedWheelEvent","wheelEvent","createWheelEvent","_ref","allocateEvent","copyPointerData","copyMouseData","copyData","nativeEvent","originalEvent","global","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","width","height","isPrimary","pressure","tangentialPressure","tiltX","tiltY","twist","FederatedMouseEvent","altKey","buttons","client","copyFrom","ctrlKey","metaKey","movement","screen","shiftKey","isTrusted","srcElement","view","which","layer","page","id","overTarget","has","get","pop","NONE","manager","listeners","_events","once","removeListener","context"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/events/EventBoundary.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n    FederatedEventTarget,\n    IFederatedContainer\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof events\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: FederatedEventTarget[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: FederatedEventTarget[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: FederatedEventTarget): FederatedEventTarget[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._mask} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        type = type ?? e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof IFederatedContainer;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: FederatedEventTarget[]): FederatedEventTarget\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: FederatedEventTarget\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as FederatedEventTarget\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n        if (!e.currentTarget.isInteractive()) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}