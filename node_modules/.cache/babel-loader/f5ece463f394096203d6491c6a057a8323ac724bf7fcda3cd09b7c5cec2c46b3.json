{"ast":null,"code":"import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = (_ref, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  let {\n    x,\n    y\n  } = _ref;\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry) {\n  let xAxisRotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  let largeArcFlag = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n  let sweepFlag = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out);\n  let {\n    ang1,\n    ang2\n  } = out;\n  const {\n    centerX,\n    centerY\n  } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = {\n    x: 0,\n    y: 0\n  };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const {\n      x: x1,\n      y: y1\n    } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const {\n      x: x2,\n      y: y2\n    } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const {\n      x,\n      y\n    } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(points, lastX, lastY, x1, y1, x2, y2, x, y);\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\nexport { buildArcToSvg };","map":{"version":3,"names":["TAU","Math","PI","out","centerX","centerY","ang1","ang2","mapToEllipse","_ref","rx","ry","cosPhi","sinPhi","out2","x","y","xp","yp","approxUnitArc","a1","tan","a","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","dot","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxSq","pow","rySq","pxpSq","pypSq","radicant","sqrt","centerXp","centerYp","vx1","vy1","vx2","vy2","buildArcToSvg","points","xAxisRotation","arguments","length","undefined","abs","lambda","ratio","segments","max","ceil","lastX","lastY","outCurvePoint","i","curve","buildAdaptiveBezier"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts"],"sourcesContent":["import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}