{"ast":null,"code":"import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      var _attribute$location, _attribute$format, _attribute$offset, _attribute$instance;\n      (_attribute$location = attribute.location) !== null && _attribute$location !== void 0 ? _attribute$location : attribute.location = attributeData.location;\n      (_attribute$format = attribute.format) !== null && _attribute$format !== void 0 ? _attribute$format : attribute.format = attributeData.format;\n      (_attribute$offset = attribute.offset) !== null && _attribute$offset !== void 0 ? _attribute$offset : attribute.offset = attributeData.offset;\n      (_attribute$instance = attribute.instance) !== null && _attribute$instance !== void 0 ? _attribute$instance : attribute.instance = attributeData.instance;\n    } else {\n      warn(\"Attribute \".concat(i, \" is not present in the shader, but is present in the geometry. Unable to infer attribute details.\"));\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const {\n    buffers,\n    attributes\n  } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    var _attribute$stride, _attribute$start;\n    const attribute = attributes[j];\n    (_attribute$stride = attribute.stride) !== null && _attribute$stride !== void 0 ? _attribute$stride : attribute.stride = tempStride[attribute.buffer.uid];\n    (_attribute$start = attribute.start) !== null && _attribute$start !== void 0 ? _attribute$start : attribute.start = tempStart[attribute.buffer.uid];\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\nexport { ensureAttributes };","map":{"version":3,"names":["ensureAttributes","geometry","extractedData","i","attributes","attribute","attributeData","_attribute$location","_attribute$format","_attribute$offset","_attribute$instance","location","format","offset","instance","warn","concat","ensureStartAndStride","buffers","tempStride","tempStart","j","buffer","uid","getAttributeInfoFromFormat","stride","_attribute$stride","_attribute$start","start"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts"],"sourcesContent":["import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.location ??= attributeData.location;\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n"],"mappings":";;;AAiBgB,SAAAA,iBACZC,QAAA,EACAC,aAEJ;EACe,WAAAC,CAAA,IAAKF,QAAA,CAASG,UACzB;IACU,MAAAC,SAAA,GAAYJ,QAAS,CAAAG,UAAA,CAAWD,CAAC;IACjC,MAAAG,aAAA,GAAgBJ,aAAA,CAAcC,CAAC;IAErC,IAAIG,aACJ;MAAA,IAAAC,mBAAA,EAAAC,iBAAA,EAAAC,iBAAA,EAAAC,mBAAA;MACc,CAAAH,mBAAA,GAAAF,SAAA,CAAAM,QAAA,cAAAJ,mBAAA,cAAAA,mBAAA,GAAVF,SAAU,CAAAM,QAAA,GAAaL,aAAc,CAAAK,QAAA;MAC3B,CAAAH,iBAAA,GAAAH,SAAA,CAAAO,MAAA,cAAAJ,iBAAA,cAAAA,iBAAA,GAAVH,SAAU,CAAAO,MAAA,GAAWN,aAAc,CAAAM,MAAA;MACzB,CAAAH,iBAAA,GAAAJ,SAAA,CAAAQ,MAAA,cAAAJ,iBAAA,cAAAA,iBAAA,GAAVJ,SAAU,CAAAQ,MAAA,GAAWP,aAAc,CAAAO,MAAA;MACzB,CAAAH,mBAAA,GAAAL,SAAA,CAAAS,QAAA,cAAAJ,mBAAA,cAAAA,mBAAA,GAAVL,SAAU,CAAAS,QAAA,GAAaR,aAAc,CAAAQ,QAAA;IAAA,CAGzC;MAESC,IAAA,cAAAC,MAAA,CAAab,CAAC,sGAAmG;IAAA;EAC1H;EAGJc,oBAAA,CAAqBhB,QAAQ;AACjC;AAEA,SAASgB,qBAAqBhB,QAC9B;EACU;IAAEiB,OAAS;IAAAd;EAAA,CAAe,GAAAH,QAAA;EAEhC,MAAMkB,UAAA,GAAqC,EAAC;EAC5C,MAAMC,SAAA,GAAoC,EAAC;EAE3C,WAAWC,CAAA,IAAKH,OAChB;IACU,MAAAI,MAAA,GAASJ,OAAA,CAAQG,CAAC;IAEbF,UAAA,CAAAG,MAAA,CAAOC,GAAG,CAAI;IACfH,SAAA,CAAAE,MAAA,CAAOC,GAAG,CAAI;EAAA;EAG5B,WAAWF,CAAA,IAAKjB,UAChB;IACU,MAAAC,SAAA,GAAYD,UAAA,CAAWiB,CAAC;IAE9BF,UAAA,CAAWd,SAAA,CAAUiB,MAAO,CAAAC,GAAG,KAAKC,0BAA2B,CAAAnB,SAAA,CAAUO,MAAM,CAAE,CAAAa,MAAA;EAAA;EAGrF,WAAWJ,CAAA,IAAKjB,UAChB;IAAA,IAAAsB,iBAAA,EAAAC,gBAAA;IACU,MAAAtB,SAAA,GAAYD,UAAA,CAAWiB,CAAC;IAE9B,CAAAK,iBAAA,GAAArB,SAAA,CAAUoB,MAAA,cAAAC,iBAAA,cAAAA,iBAAA,GAAVrB,SAAU,CAAAoB,MAAA,GAAWN,UAAW,CAAAd,SAAA,CAAUiB,MAAA,CAAOC,GAAG;IAEpD,CAAAI,gBAAA,GAAAtB,SAAA,CAAUuB,KAAA,cAAAD,gBAAA,cAAAA,gBAAA,GAAVtB,SAAU,CAAAuB,KAAA,GAAUR,SAAU,CAAAf,SAAA,CAAUiB,MAAA,CAAOC,GAAG;IAElDH,SAAA,CAAUf,SAAA,CAAUiB,MAAO,CAAAC,GAAG,KAAKC,0BAA2B,CAAAnB,SAAA,CAAUO,MAAM,CAAE,CAAAa,MAAA;EAAA;AAExF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}