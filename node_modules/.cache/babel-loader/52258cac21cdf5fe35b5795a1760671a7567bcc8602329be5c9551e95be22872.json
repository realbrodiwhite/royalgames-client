{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\"use strict\";\nconst idHash = /* @__PURE__ */Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor() {\n    var _options$addressModeU, _options$addressModeV, _options$addressModeW, _options$magFilter, _options$minFilter, _options$mipmapFilter, _options$maxAnisotrop;\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = {\n      ..._TextureStyle.defaultOptions,\n      ...options\n    };\n    this.addressMode = options.addressMode;\n    this.addressModeU = (_options$addressModeU = options.addressModeU) !== null && _options$addressModeU !== void 0 ? _options$addressModeU : this.addressModeU;\n    this.addressModeV = (_options$addressModeV = options.addressModeV) !== null && _options$addressModeV !== void 0 ? _options$addressModeV : this.addressModeV;\n    this.addressModeW = (_options$addressModeW = options.addressModeW) !== null && _options$addressModeW !== void 0 ? _options$addressModeW : this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = (_options$magFilter = options.magFilter) !== null && _options$magFilter !== void 0 ? _options$magFilter : this.magFilter;\n    this.minFilter = (_options$minFilter = options.minFilter) !== null && _options$minFilter !== void 0 ? _options$minFilter : this.minFilter;\n    this.mipmapFilter = (_options$mipmapFilter = options.mipmapFilter) !== null && _options$mipmapFilter !== void 0 ? _options$mipmapFilter : this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = (_options$maxAnisotrop = options.maxAnisotropy) !== null && _options$maxAnisotrop !== void 0 ? _options$maxAnisotrop : 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = \"\".concat(this.addressModeU, \"-\").concat(this.addressModeV, \"-\").concat(this.addressModeW, \"-\").concat(this.magFilter, \"-\").concat(this.minFilter, \"-\").concat(this.mipmapFilter, \"-\").concat(this.lodMinClamp, \"-\").concat(this.lodMaxClamp, \"-\").concat(this.compare, \"-\").concat(this._maxAnisotropy);\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\nexport { TextureStyle };","map":{"version":3,"names":["idHash","Object","create","createResourceIdFromString","value","id","uid","_TextureStyle","EventEmitter","constructor","_options$addressModeU","_options$addressModeV","_options$addressModeW","_options$magFilter","_options$minFilter","_options$mipmapFilter","_options$maxAnisotrop","options","arguments","length","undefined","_resourceType","_touched","_maxAnisotropy","destroyed","defaultOptions","addressMode","addressModeU","addressModeV","addressModeW","scaleMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","compare","maxAnisotropy","wrapMode","deprecation","v8_0_0","Math","min","_resourceId","_sharedResourceId","_generateResourceId","update","emit","bigKey","concat","destroy","removeAllListeners","TextureStyle"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}