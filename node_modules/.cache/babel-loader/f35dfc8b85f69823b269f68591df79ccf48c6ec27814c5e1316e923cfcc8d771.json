{"ast":null,"code":"import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\n\"use strict\";\nconst effectsMixin = {\n  _mask: null,\n  _filters: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1) return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    if (this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1) return;\n    this.effects.splice(index, 1);\n    if (!this.isRenderGroupRoot && this.renderGroup) {\n      this.renderGroup.structureDidChange = true;\n    }\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    this._mask || (this._mask = {\n      mask: null,\n      effect: null\n    });\n    if (this._mask.mask === value) return;\n    if (this._mask.effect) {\n      this.removeEffect(this._mask.effect);\n      MaskEffectManager.returnMaskEffect(this._mask.effect);\n      this._mask.effect = null;\n    }\n    this._mask.mask = value;\n    if (value === null || value === void 0) return;\n    const effect = MaskEffectManager.getMaskEffect(value);\n    this._mask.effect = effect;\n    this.addEffect(effect);\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    var _this$_mask;\n    return (_this$_mask = this._mask) === null || _this$_mask === void 0 ? void 0 : _this$_mask.mask;\n  },\n  set filters(value) {\n    var _value;\n    if (!Array.isArray(value) && value) value = [value];\n    value = value;\n    this._filters || (this._filters = {\n      filters: null,\n      effect: null,\n      filterArea: null\n    });\n    const hasFilters = ((_value = value) === null || _value === void 0 ? void 0 : _value.length) > 0;\n    const didChange = this._filters.effect && !hasFilters || !this._filters.effect && hasFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    this._filters.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        const effect = BigPool.get(FilterEffect);\n        this._filters.effect = effect;\n        this.addEffect(effect);\n      } else {\n        const effect = this._filters.effect;\n        this.removeEffect(effect);\n        effect.filterArea = null;\n        effect.filters = null;\n        this._filters.effect = null;\n        BigPool.return(effect);\n      }\n    }\n    if (hasFilters) {\n      this._filters.effect.filters = value;\n      this._filters.effect.filterArea = this.filterArea;\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    var _this$_filters;\n    return (_this$_filters = this._filters) === null || _this$_filters === void 0 ? void 0 : _this$_filters.filters;\n  },\n  set filterArea(value) {\n    this._filters || (this._filters = {\n      filters: null,\n      effect: null,\n      filterArea: null\n    });\n    this._filters.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    var _this$_filters2;\n    return (_this$_filters2 = this._filters) === null || _this$_filters2 === void 0 ? void 0 : _this$_filters2.filterArea;\n  }\n};\nexport { effectsMixin };","map":{"version":3,"names":["effectsMixin","_mask","_filters","effects","addEffect","effect","index","indexOf","push","sort","a","b","priority","renderGroup","structureDidChange","_updateIsSimple","removeEffect","splice","isRenderGroupRoot","mask","value","MaskEffectManager","returnMaskEffect","getMaskEffect","_this$_mask","filters","_value","Array","isArray","filterArea","hasFilters","length","didChange","slice","Object","freeze","BigPool","get","FilterEffect","return","_this$_filters","_this$_filters2"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts"],"sourcesContent":["import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: number | Container | null;\n    filters?: Filter | Filter[];\n}\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _mask?: {mask: unknown, effect: Effect};\n    _filters?: {\n        filters: readonly Filter[],\n        effect: FilterEffect\n        filterArea?: Rectangle,\n    },\n    filterArea?: Rectangle,\n    effects?: Effect[];\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _mask: null,\n    _filters: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        if (!this.isRenderGroupRoot && this.renderGroup)\n        {\n            this.renderGroup.structureDidChange = true;\n        }\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: number | Container | null)\n    {\n        this._mask ||= { mask: null, effect: null };\n\n        if (this._mask.mask === value) return;\n\n        if (this._mask.effect)\n        {\n            this.removeEffect(this._mask.effect);\n\n            MaskEffectManager.returnMaskEffect(this._mask.effect);\n\n            this._mask.effect = null;\n        }\n\n        this._mask.mask = value;\n\n        if (value === null || value === undefined) return;\n\n        const effect = MaskEffectManager.getMaskEffect(value);\n\n        this._mask.effect = effect;\n\n        this.addEffect(effect);\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._mask?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        // by reusing the same effect.. rather than adding and removing from the pool!\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        const hasFilters = value?.length > 0;\n        const didChange = (this._filters.effect && !hasFilters) || (!this._filters.effect && hasFilters);\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        this._filters.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                const effect = BigPool.get(FilterEffect);\n\n                this._filters.effect = effect;\n                this.addEffect(effect);\n            }\n            else\n            {\n                const effect = this._filters.effect;\n\n                this.removeEffect(effect);\n\n                effect.filterArea = null;\n                effect.filters = null;\n\n                this._filters.effect = null;\n                BigPool.return(effect as PoolItem);\n            }\n        }\n\n        if (hasFilters)\n        {\n            this._filters.effect.filters = value as Filter[];\n            this._filters.effect.filterArea = this.filterArea;\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filters?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filters ||= { filters: null, effect: null, filterArea: null };\n\n        this._filters.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filters?.filterArea;\n    },\n\n} as Container;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}