{"ast":null,"code":"import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\"use strict\";\nclass DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    var _dynamicOptions$skipK, _dynamicOptions$resol, _dynamicOptions$paddi;\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 4;\n    this._measureCache = /* @__PURE__ */Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = options;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = (_dynamicOptions$skipK = dynamicOptions.skipKerning) !== null && _dynamicOptions$skipK !== void 0 ? _dynamicOptions$skipK : false;\n    this.resolution = (_dynamicOptions$resol = dynamicOptions.resolution) !== null && _dynamicOptions$resol !== void 0 ? _dynamicOptions$resol : 1;\n    this._padding = (_dynamicOptions$paddi = dynamicOptions.padding) !== null && _dynamicOptions$paddi !== void 0 ? _dynamicOptions$paddi : 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter(char => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length) return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let {\n      canvas,\n      context\n    } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    const widthScale = style.fontStyle === \"italic\" ? 2 : 1;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    for (let i = 0; i < charList.length; i++) {\n      var _style$dropShadow$dis, _style$dropShadow, _style$_stroke$width, _style$_stroke;\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = widthScale * metrics.width * fontScale;\n      const height = metrics.height * fontScale;\n      const paddedWidth = width + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > 512) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > 512) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - ((_style$dropShadow$dis = (_style$dropShadow = style.dropShadow) === null || _style$dropShadow === void 0 ? void 0 : _style$dropShadow.distance) !== null && _style$dropShadow$dis !== void 0 ? _style$dropShadow$dis : 0) - ((_style$_stroke$width = (_style$_stroke = style._stroke) === null || _style$_stroke === void 0 ? void 0 : _style$_stroke.width) !== null && _style$_stroke$width !== void 0 ? _style$_stroke$width : 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, style);\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(currentX / px * textureSource.width, currentY / py * textureSource.height, paddedWidth / px * textureSource.width, paddedHeight / py * textureSource.height);\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\"\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    var _stroke$width;\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = (_stroke$width = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _stroke$width !== void 0 ? _stroke$width : 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = \"rgba(\".concat(rgb[0] * 255, \",\").concat(rgb[1] * 255, \",\").concat(rgb[2] * 255, \",\").concat(shadowOptions.alpha, \")\");\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    var _stroke$width2;\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = ((_stroke$width2 = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _stroke$width2 !== void 0 ? _stroke$width2 : 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const {\n        canvasAndContext,\n        texture\n      } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n}\nexport { DynamicBitmapFont };","map":{"version":3,"names":["DynamicBitmapFont","AbstractBitmapFont","constructor","options","_dynamicOptions$skipK","_dynamicOptions$resol","_dynamicOptions$paddi","resolution","pages","_padding","_measureCache","Object","create","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","style","clone","overrideFill","_fill","color","alpha","texture","Texture","WHITE","fill","requestedFontSize","fontSize","baseMeasurementFontSize","font","fontStringFromTextStyle","overrideSize","_stroke","width","baseRenderedFontSize","_style","skipKerning","padding","fontMetrics","CanvasTextMetrics","measureFont","lineHeight","ensureCharacters","chars","charList","resolveCharacters","filter","char","includes","index","self","indexOf","length","pageData","_nextPage","canvas","context","canvasAndContext","textureSource","source","currentX","currentY","fontScale","widthScale","fontStyle","maxCharHeight","skipTexture","i","_style$dropShadow$dis","_style$dropShadow","_style$_stroke$width","_style$_stroke","metrics","measureText","height","paddedWidth","paddedHeight","Math","ceil","max","update","pageData2","xAdvance","dropShadow","distance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","frame","Rectangle","_applyKerning","pageTextures","deprecation","v8_0_0","newChars","measureCache","first","j","second","c1","c2","total","amount","textureResolution","CanvasPool","getOptimalCanvasAndContext","_setupContext","ImageSource","resource","alphaMode","_stroke$width","scale","textBaseline","stroke","strokeThickness","lineWidth","lineJoin","join","miterLimit","strokeStyle","getCanvasFillStyle","fillStyle","shadowOptions","rgb","Color","shared","setValue","toArray","dropShadowBlur","blur","dropShadowDistance","shadowColor","concat","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","x","y","_stroke$width2","text","fontProperties","tx","ty","descent","strokeText","fillText","destroy","returnCanvasAndContext"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts"],"sourcesContent":["import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { TextStyle } from '../text/TextStyle';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 4;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = options;\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        const widthScale = style.fontStyle === 'italic' ? 2 : 1;\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps heigh\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = (widthScale * metrics.width) * fontScale;\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = width + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > 512)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > 512)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(512, 512, textureResolution);\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload'\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}