{"ast":null,"code":"import { Color } from '../../../color/Color.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { nextPow2 } from '../../../maths/misc/pow2.mjs';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextMetrics } from './CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle.mjs';\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTextureSize(text, resolution, style) {\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    width = Math.ceil(width - 1e-6);\n    height = Math.ceil(height - 1e-6);\n    width = nextPow2(width);\n    height = nextPow2(height);\n    return {\n      width,\n      height\n    };\n  }\n  getTexture(options, resolution, style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style,\n        resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    const {\n      texture,\n      canvasAndContext\n    } = this.createTextureAndCanvas(options);\n    this._renderer.texture.initSource(texture._source);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  createTextureAndCanvas(options) {\n    var _options$resolution;\n    const {\n      text,\n      style\n    } = options;\n    const resolution = (_options$resolution = options.resolution) !== null && _options$resolution !== void 0 ? _options$resolution : this._renderer.resolution;\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n    const {\n      canvas\n    } = canvasAndContext;\n    this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n    const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n    if (style.trim) {\n      const trimmed = getCanvasBoundingBox(canvas, resolution);\n      texture.frame.copyFrom(trimmed);\n      texture.updateUvs();\n    }\n    return {\n      texture,\n      canvasAndContext\n    };\n  }\n  getManagedTexture(text) {\n    const textKey = text._getKey();\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const {\n      texture,\n      canvasAndContext\n    } = this.createTextureAndCanvas(text);\n    this._activeTextures[textKey] = {\n      canvasAndContext,\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n      TexturePool.returnTexture(activeTexture.texture);\n      const source = activeTexture.texture.source;\n      source.resource = null;\n      source.uploadMethodId = \"unknown\";\n      source.alphaMode = \"no-premultiply-alpha\";\n      this._activeTextures[textKey] = null;\n    }\n  }\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey].usageCount;\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   *\n   * By default this is used internally to ensure the texture is correct before rendering,\n   * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n   * and then shared across multiple Sprites.\n   * @param text\n   * @param style\n   * @param resolution\n   * @param canvasAndContext\n   */\n  renderTextToCanvas(text, style, resolution, canvasAndContext) {\n    var _style$_stroke;\n    const {\n      canvas,\n      context\n    } = canvasAndContext;\n    const font = fontStringFromTextStyle(style);\n    const measured = CanvasTextMetrics.measureText(text || \" \", style);\n    const lines = measured.lines;\n    const lineHeight = measured.lineHeight;\n    const lineWidths = measured.lineWidths;\n    const maxLineWidth = measured.maxLineWidth;\n    const fontProperties = measured.fontProperties;\n    const height = canvas.height;\n    context.resetTransform();\n    context.scale(resolution, resolution);\n    const padding = style.padding * 2;\n    context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n    if ((_style$_stroke = style._stroke) !== null && _style$_stroke !== void 0 && _style$_stroke.width) {\n      const strokeStyle = style._stroke;\n      context.lineWidth = strokeStyle.width;\n      context.miterLimit = strokeStyle.miterLimit;\n      context.lineJoin = strokeStyle.join;\n      context.lineCap = strokeStyle.cap;\n    }\n    context.font = font;\n    let linePositionX;\n    let linePositionY;\n    const passesCount = style.dropShadow ? 2 : 1;\n    for (let i = 0; i < passesCount; ++i) {\n      var _style$_stroke$width, _style$_stroke3;\n      const isShadowPass = style.dropShadow && i === 0;\n      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;\n      const dsOffsetShadow = dsOffsetText * resolution;\n      if (isShadowPass) {\n        context.fillStyle = \"black\";\n        context.strokeStyle = \"black\";\n        const shadowOptions = style.dropShadow;\n        const dropShadowColor = shadowOptions.color;\n        const dropShadowAlpha = shadowOptions.alpha;\n        context.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();\n        const dropShadowBlur = shadowOptions.blur * resolution;\n        const dropShadowDistance = shadowOptions.distance * resolution;\n        context.shadowBlur = dropShadowBlur;\n        context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n        context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;\n      } else {\n        var _style$_fill$alpha, _style$_fill, _style$_stroke2;\n        context.globalAlpha = (_style$_fill$alpha = (_style$_fill = style._fill) === null || _style$_fill === void 0 ? void 0 : _style$_fill.alpha) !== null && _style$_fill$alpha !== void 0 ? _style$_fill$alpha : 1;\n        context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n        if ((_style$_stroke2 = style._stroke) !== null && _style$_stroke2 !== void 0 && _style$_stroke2.width) {\n          context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n        }\n        context.shadowColor = \"black\";\n      }\n      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n      if (lineHeight - fontProperties.fontSize < 0) {\n        linePositionYShift = 0;\n      }\n      const strokeWidth = (_style$_stroke$width = (_style$_stroke3 = style._stroke) === null || _style$_stroke3 === void 0 ? void 0 : _style$_stroke3.width) !== null && _style$_stroke$width !== void 0 ? _style$_stroke$width : 0;\n      for (let i2 = 0; i2 < lines.length; i2++) {\n        var _style$_stroke4;\n        linePositionX = strokeWidth / 2;\n        linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + linePositionYShift;\n        if (style.align === \"right\") {\n          linePositionX += maxLineWidth - lineWidths[i2];\n        } else if (style.align === \"center\") {\n          linePositionX += (maxLineWidth - lineWidths[i2]) / 2;\n        }\n        if ((_style$_stroke4 = style._stroke) !== null && _style$_stroke4 !== void 0 && _style$_stroke4.width) {\n          this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, true);\n        }\n        if (style._fill !== void 0) {\n          this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);\n        }\n      }\n    }\n  }\n  /**\n   * Render the text with letter-spacing.\n   * @param text - The text to draw\n   * @param style\n   * @param canvasAndContext\n   * @param x - Horizontal position to draw the text\n   * @param y - Vertical position to draw the text\n   * @param isStroke - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   */\n  _drawLetterSpacing(text, style, canvasAndContext, x, y) {\n    let isStroke = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    const {\n      context\n    } = canvasAndContext;\n    const letterSpacing = style.letterSpacing;\n    let useExperimentalLetterSpacing = false;\n    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = \"\".concat(letterSpacing, \"px\");\n        context.textLetterSpacing = \"\".concat(letterSpacing, \"px\");\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    if (letterSpacing === 0 || useExperimentalLetterSpacing) {\n      if (isStroke) {\n        context.strokeText(text, x, y);\n      } else {\n        context.fillText(text, x, y);\n      }\n      return;\n    }\n    let currentPosition = x;\n    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n    let previousWidth = context.measureText(text).width;\n    let currentWidth = 0;\n    for (let i = 0; i < stringArray.length; ++i) {\n      const currentChar = stringArray[i];\n      if (isStroke) {\n        context.strokeText(currentChar, currentPosition, y);\n      } else {\n        context.fillText(currentChar, currentPosition, y);\n      }\n      let textStr = \"\";\n      for (let j = i + 1; j < stringArray.length; ++j) {\n        textStr += stringArray[j];\n      }\n      currentWidth = context.measureText(textStr).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  }\n  destroy() {\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"canvasText\"\n};\nexport { CanvasTextSystem };","map":{"version":3,"names":["CanvasTextSystem","constructor","_renderer","_activeTextures","getTextureSize","text","resolution","style","measured","CanvasTextMetrics","measureText","width","Math","ceil","max","padding","height","nextPow2","getTexture","options","_textKey","deprecation","TextStyle","texture","canvasAndContext","createTextureAndCanvas","initSource","_source","CanvasPool","returnCanvasAndContext","_options$resolution","getOptimalCanvasAndContext","canvas","renderTextToCanvas","getPo2TextureFromSource","trim","trimmed","getCanvasBoundingBox","frame","copyFrom","updateUvs","getManagedTexture","textKey","_getKey","_increaseReferenceCount","usageCount","decreaseReferenceCount","activeTexture","TexturePool","returnTexture","source","resource","uploadMethodId","alphaMode","getReferenceCount","_style$_stroke","context","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","resetTransform","scale","clearRect","_stroke","strokeStyle","lineWidth","miterLimit","lineJoin","join","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","i","_style$_stroke$width","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","color","dropShadowAlpha","alpha","shadowColor","Color","shared","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","_style$_fill$alpha","_style$_fill","_style$_stroke2","globalAlpha","_fill","getCanvasFillStyle","linePositionYShift","fontSize","strokeWidth","i2","length","_style$_stroke4","ascent","align","_drawLetterSpacing","x","y","isStroke","arguments","undefined","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","concat","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","destroy","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts"],"sourcesContent":["import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n            TexturePool.returnTexture(activeTexture.texture);\n\n            const source = activeTexture.texture.source;\n\n            source.resource = null;\n            source.uploadMethodId = 'unknown';\n            source.alphaMode = 'no-premultiply-alpha';\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n\n        context.scale(resolution, resolution);\n\n        const padding = style.padding * 2;\n\n        context.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.globalAlpha = style._fill?.alpha ?? 1;\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context) : null;\n\n                if (style._stroke?.width)\n                {\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}