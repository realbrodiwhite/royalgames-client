{"ast":null,"code":"import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      var _instructions$slice;\n      this.instructions = (_instructions$slice = instructions === null || instructions === void 0 ? void 0 : instructions.slice()) !== null && _instructions$slice !== void 0 ? _instructions$slice : [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({\n      action: \"addPath\",\n      data: [path, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  arc() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.instructions.push({\n      action: \"arc\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  arcTo() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this.instructions.push({\n      action: \"arcTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    this.instructions.push({\n      action: \"arcToSvg\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    this.instructions.push({\n      action: \"bezierCurveTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({\n      action: \"bezierCurveTo\",\n      data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({\n      action: \"closePath\",\n      data: []\n    });\n    this._dirty = true;\n    return this;\n  }\n  ellipse() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n    this.instructions.push({\n      action: \"ellipse\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  lineTo() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    this.instructions.push({\n      action: \"lineTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  moveTo() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    this.instructions.push({\n      action: \"moveTo\",\n      data: args\n    });\n    return this;\n  }\n  quadraticCurveTo() {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    this.instructions.push({\n      action: \"quadraticCurveTo\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({\n      action: \"quadraticCurveTo\",\n      data: [cpx1, cpy1, x, y, smoothness]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({\n      action: \"rect\",\n      data: [x, y, w, h, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({\n      action: \"circle\",\n      data: [x, y, radius, transform]\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundRect() {\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    this.instructions.push({\n      action: \"roundRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  poly() {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    this.instructions.push({\n      action: \"poly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly() {\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    this.instructions.push({\n      action: \"regularPoly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly() {\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    this.instructions.push({\n      action: \"roundPoly\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  roundShape() {\n    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      args[_key13] = arguments[_key13];\n    }\n    this.instructions.push({\n      action: \"roundShape\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  filletRect() {\n    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n      args[_key14] = arguments[_key14];\n    }\n    this.instructions.push({\n      action: \"filletRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect() {\n    for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n      args[_key15] = arguments[_key15];\n    }\n    this.instructions.push({\n      action: \"chamferRect\",\n      data: args\n    });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius = innerRadius || radius / 2;\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({\n          action: instruction.action,\n          data: instruction.data.slice()\n        });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity()) return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\nexport { GraphicsPath };","map":{"version":3,"names":["GraphicsPath","constructor","instructions","uid","_dirty","SVGToGraphicsPath","_instructions$slice","slice","shapePath","_shapePath","ShapePath","buildPath","addPath","path","transform","clone","push","action","data","arc","_len","arguments","length","args","Array","_key","arcTo","_len2","_key2","arcToSvg","_len3","_key3","bezierCurveTo","_len4","_key4","bezierCurveToShort","cp2x","cp2y","x","y","smoothness","last","lastPoint","getLastPoint","Point","shared","cp1x","cp1y","currentX","currentY","closePath","ellipse","_len5","_key5","lineTo","_len6","_key6","moveTo","_len7","_key7","quadraticCurveTo","_len8","_key8","quadraticCurveToShort","cpx1","cpy1","rect","w","h","circle","radius","roundRect","_len9","_key9","poly","_len10","_key10","regularPoly","_len11","_key11","roundPoly","_len12","_key12","roundShape","_len13","_key13","filletRect","_len14","_key14","chamferRect","_len15","_key15","star","points","innerRadius","rotation","startAngle","Math","PI","len","delta","polygon","i","r","angle","cos","sin","deep","undefined","newGraphicsPath2D","instruction","clear","matrix","isIdentity","a","b","c","d","tx","ty","cpx2","cpy2","rx","ry","adjustTransform","warn","bounds","out","index","lastInstruction","currentMatrix","prepend"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts"],"sourcesContent":["import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    public uid = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     */\n    constructor(instructions?: string | PathInstruction[])\n    {\n        if (typeof instructions === 'string')\n        {\n            SVGToGraphicsPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}