{"ast":null,"code":"import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => \"\".concat(bundleId).concat(this._bundleIdConnector).concat(assetId),\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(\"\".concat(bundleId).concat(this._bundleIdConnector), \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    var _bundleIdentifier$con, _bundleIdentifier$cre, _bundleIdentifier$ext;\n    this._bundleIdConnector = (_bundleIdentifier$con = bundleIdentifier.connector) !== null && _bundleIdentifier$con !== void 0 ? _bundleIdentifier$con : this._bundleIdConnector;\n    this._createBundleAssetId = (_bundleIdentifier$cre = bundleIdentifier.createBundleAssetId) !== null && _bundleIdentifier$cre !== void 0 ? _bundleIdentifier$cre : this._createBundleAssetId;\n    this._extractAssetIdFromBundle = (_bundleIdentifier$ext = bundleIdentifier.extractAssetIdFromBundle) !== null && _bundleIdentifier$ext !== void 0 ? _bundleIdentifier$ext : this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer() {\n    for (var _len = arguments.length, preferOrders = new Array(_len), _key = 0; _key < _len; _key++) {\n      preferOrders[_key] = arguments[_key];\n    }\n    preferOrders.forEach(prefer => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map(key => \"\".concat(encodeURIComponent(key), \"=\").concat(encodeURIComponent(queryValues[key]))).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const {\n      alias,\n      src\n    } = asset;\n    const aliasesToUse = convertToList(alias || src, value => {\n      if (typeof value === \"string\") return value;\n      if (Array.isArray(value)) return value.map(v => {\n        var _v$src;\n        return (_v$src = v === null || v === void 0 ? void 0 : v.src) !== null && _v$src !== void 0 ? _v$src : v;\n      });\n      if (value !== null && value !== void 0 && value.src) return value.src;\n      return value;\n    }, true);\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach(bundle => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(_ref => {\n        let [alias, src] = _ref;\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return {\n            alias,\n            src\n          };\n        }\n        return {\n          alias,\n          ...src\n        };\n      });\n    }\n    convertedAssets.forEach(asset => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map(name => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = key => {\n      if (this.hasKey(key)) {\n        warn(\"[Resolver] already has key: \".concat(key, \" overwriting\"));\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach(asset => {\n      const {\n        src\n      } = asset;\n      let {\n        data,\n        format,\n        loadParser\n      } = asset;\n      const srcsToUse = convertToList(src).map(src2 => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach(srcs => {\n        srcs.forEach(src2 => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            var _src2$data, _src2$format, _src2$loadParser;\n            data = (_src2$data = src2.data) !== null && _src2$data !== void 0 ? _src2$data : data;\n            format = (_src2$format = src2.format) !== null && _src2$format !== void 0 ? _src2$format : format;\n            loadParser = (_src2$loadParser = src2.loadParser) !== null && _src2$loadParser !== void 0 ? _src2$loadParser : loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(\"[Resolver] alias is undefined for this asset: \".concat(formattedAsset.src));\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach(alias => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach(bundleId => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach(key => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder === null || preferredOrder === void 0 ? void 0 : preferredOrder.priority.forEach(priorityKey => {\n            preferredOrder.params[priorityKey].forEach(value => {\n              const filteredAssets = assets.filter(asset => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find(preference => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams) return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return \"\".concat(url).concat(paramConnector).concat(this._defaultSearchParams);\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    var _ref2, _ref3;\n    const {\n      aliases,\n      data: assetData,\n      loadParser,\n      format\n    } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = (_ref2 = aliases !== null && aliases !== void 0 ? aliases : formattedAsset.alias) !== null && _ref2 !== void 0 ? _ref2 : [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = {\n      ...(assetData || {}),\n      ...formattedAsset.data\n    };\n    formattedAsset.loadParser = loadParser !== null && loadParser !== void 0 ? loadParser : formattedAsset.loadParser;\n    formattedAsset.format = (_ref3 = format !== null && format !== void 0 ? format : formattedAsset.format) !== null && _ref3 !== void 0 ? _ref3 : getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\nexport { Resolver, getUrlExtension };","map":{"version":3,"names":["Resolver","constructor","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","concat","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_parsers","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","_bundleIdentifier$con","_bundleIdentifier$cre","_bundleIdentifier$ext","Error","prefer","_len","arguments","length","preferOrders","Array","_key","forEach","push","priority","Object","keys","params","basePath","_basePath","rootPath","_rootPath","parsers","reset","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","queryValues","map","key","encodeURIComponent","join","getAlias","asset","alias","src","aliasesToUse","convertToList","value","isArray","v","_v$src","addManifest","manifest","warn","bundles","bundle","addBundle","name","assets","assetNames","convertedAssets","entries","_ref","srcs","aliases","ids","bundleAssetId","bundleIds","add","keyCheck","hasKey","assetArray","data","format","loadParser","srcsToUse","src2","createStringVariations","resolvedAssets","formattedAsset","i","parser","test","parse","_src2$data","_src2$format","_src2$loadParser","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","out","results","resolve","resolveUrl","result","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","filter","hasBundle","preferred","find","preference","includes","_appendDefaultSearchParams","url","paramConnector","_ref2","_ref3","assetData","path","toAbsolute","getUrlExtension","RETINA_PREFIX","split","pop","shift"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/assets/resolver/Resolver.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}