{"ast":null,"code":"import { KTX } from '../ktx2/const.mjs';\n\"use strict\";\nfunction parseKTX(arrayBuffer, supportedFormats) {\n  const dataView = new DataView(arrayBuffer);\n  if (!validate(dataView)) {\n    throw new Error(\"Invalid KTX identifier in header\");\n  }\n  const {\n    littleEndian,\n    glType,\n    glFormat,\n    glInternalFormat,\n    pixelWidth,\n    pixelHeight,\n    numberOfMipmapLevels,\n    offset\n  } = parseKTXHeader(dataView);\n  const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];\n  if (!textureFormat) {\n    throw new Error(\"Unknown texture format \".concat(glInternalFormat));\n  }\n  if (!supportedFormats.includes(textureFormat)) {\n    throw new Error(\"Unsupported texture format: \".concat(textureFormat, \", supportedFormats: \").concat(supportedFormats));\n  }\n  const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);\n  const imageBuffers = getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian);\n  return {\n    format: textureFormat,\n    width: pixelWidth,\n    height: pixelHeight,\n    resource: imageBuffers,\n    alphaMode: \"no-premultiply-alpha\"\n  };\n}\nfunction getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset, numberOfMipmapLevels, littleEndian) {\n  const alignedWidth = pixelWidth + 3 & ~3;\n  const alignedHeight = pixelHeight + 3 & ~3;\n  let imagePixels = pixelWidth * pixelHeight;\n  if (glType === 0) {\n    imagePixels = alignedWidth * alignedHeight;\n  }\n  let mipByteSize = imagePixels * imagePixelByteSize;\n  let mipWidth = pixelWidth;\n  let mipHeight = pixelHeight;\n  let alignedMipWidth = alignedWidth;\n  let alignedMipHeight = alignedHeight;\n  let imageOffset = offset;\n  const imageBuffers = new Array(numberOfMipmapLevels);\n  for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {\n    const imageSize = dataView.getUint32(imageOffset, littleEndian);\n    let elementOffset = imageOffset + 4;\n    imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);\n    elementOffset += mipByteSize;\n    imageOffset += imageSize + 4;\n    imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - imageOffset % 4 : imageOffset;\n    mipWidth = mipWidth >> 1 || 1;\n    mipHeight = mipHeight >> 1 || 1;\n    alignedMipWidth = mipWidth + 4 - 1 & ~(4 - 1);\n    alignedMipHeight = mipHeight + 4 - 1 & ~(4 - 1);\n    mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n  }\n  return imageBuffers;\n}\nfunction getImagePixelByteSize(glType, glFormat, glInternalFormat) {\n  let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n  if (glType !== 0) {\n    if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType]) {\n      imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];\n    } else {\n      imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];\n    }\n  }\n  if (imagePixelByteSize === void 0) {\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  }\n  return imagePixelByteSize;\n}\nfunction parseKTXHeader(dataView) {\n  const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;\n  const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);\n  const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);\n  const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n  const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);\n  const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;\n  const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;\n  const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;\n  const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);\n  const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n  const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n  if (pixelHeight === 0 || pixelDepth !== 1) {\n    throw new Error(\"Only 2D textures are supported\");\n  }\n  if (numberOfFaces !== 1) {\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  }\n  if (numberOfArrayElements !== 1) {\n    throw new Error(\"WebGL does not support array textures\");\n  }\n  return {\n    littleEndian,\n    glType,\n    glFormat,\n    glInternalFormat,\n    pixelWidth,\n    pixelHeight,\n    numberOfMipmapLevels,\n    offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData\n  };\n}\nfunction validate(dataView) {\n  for (let i = 0; i < KTX.FILE_IDENTIFIER.length; i++) {\n    if (dataView.getUint8(i) !== KTX.FILE_IDENTIFIER[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport { parseKTX };","map":{"version":3,"names":["parseKTX","arrayBuffer","supportedFormats","dataView","DataView","validate","Error","littleEndian","glType","glFormat","glInternalFormat","pixelWidth","pixelHeight","numberOfMipmapLevels","offset","parseKTXHeader","textureFormat","KTX","INTERNAL_FORMAT_TO_TEXTURE_FORMATS","concat","includes","imagePixelByteSize","getImagePixelByteSize","imageBuffers","getImageBuffers","format","width","height","resource","alphaMode","alignedWidth","alignedHeight","imagePixels","mipByteSize","mipWidth","mipHeight","alignedMipWidth","alignedMipHeight","imageOffset","Array","mipmapLevel","imageSize","getUint32","elementOffset","Uint8Array","buffer","INTERNAL_FORMAT_TO_BYTES_PER_PIXEL","TYPES_TO_BYTES_PER_COMPONENT","FORMATS_TO_COMPONENTS","TYPES_TO_BYTES_PER_PIXEL","FIELDS","ENDIANNESS","GL_TYPE","GL_FORMAT","GL_INTERNAL_FORMAT","PIXEL_WIDTH","PIXEL_HEIGHT","pixelDepth","PIXEL_DEPTH","numberOfArrayElements","NUMBER_OF_ARRAY_ELEMENTS","numberOfFaces","NUMBER_OF_FACES","NUMBER_OF_MIPMAP_LEVELS","bytesOfKeyValueData","BYTES_OF_KEY_VALUE_DATA","FILE_HEADER_SIZE","i","FILE_IDENTIFIER","length","getUint8"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/compressed-textures/ktx/parseKTX.ts"],"sourcesContent":["import { KTX } from '../ktx2/const';\n\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\n\nexport function parseKTX(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>\n{\n    const dataView = new DataView(arrayBuffer);\n\n    if (!validate(dataView))\n    {\n        throw new Error('Invalid KTX identifier in header');\n    }\n\n    const {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset,\n    } = parseKTXHeader(dataView);\n\n    const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];\n\n    if (!textureFormat)\n    {\n        throw new Error(`Unknown texture format ${glInternalFormat}`);\n    }\n    if (!supportedFormats.includes(textureFormat))\n    {\n        throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);\n    }\n\n    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);\n\n    const imageBuffers = getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset,\n        numberOfMipmapLevels, littleEndian);\n\n    return {\n        format: textureFormat,\n        width: pixelWidth,\n        height: pixelHeight,\n        resource: imageBuffers,\n        alphaMode: 'no-premultiply-alpha'\n    };\n}\n\nfunction getImageBuffers(dataView: DataView, glType: number, imagePixelByteSize: number, pixelWidth: number,\n    pixelHeight: number, offset: number, numberOfMipmapLevels: number, littleEndian: boolean)\n{\n    const alignedWidth = (pixelWidth + 3) & ~3;\n    const alignedHeight = (pixelHeight + 3) & ~3;\n    let imagePixels = pixelWidth * pixelHeight;\n\n    if (glType === 0)\n    {\n        // Align to 16 pixels (4x4 blocks)\n        imagePixels = alignedWidth * alignedHeight;\n    }\n\n    let mipByteSize = imagePixels * imagePixelByteSize;\n    let mipWidth = pixelWidth;\n    let mipHeight = pixelHeight;\n    let alignedMipWidth = alignedWidth;\n    let alignedMipHeight = alignedHeight;\n    let imageOffset = offset;\n\n    const imageBuffers = new Array<Uint8Array>(numberOfMipmapLevels);\n\n    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++)\n    {\n        const imageSize = dataView.getUint32(imageOffset, littleEndian);\n        let elementOffset = imageOffset + 4;\n\n        imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);\n\n        elementOffset += mipByteSize;\n\n        // HINT: Aligns to 4-byte boundary after jumping imageSize (in lieu of mipPadding)\n        imageOffset += imageSize + 4;// (+4 to jump the imageSize field itself)\n        imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - (imageOffset % 4) : imageOffset;\n\n        // Calculate mipWidth, mipHeight for _next_ iteration\n        mipWidth = (mipWidth >> 1) || 1;\n        mipHeight = (mipHeight >> 1) || 1;\n        alignedMipWidth = (mipWidth + 4 - 1) & ~(4 - 1);\n        alignedMipHeight = (mipHeight + 4 - 1) & ~(4 - 1);\n\n        // Each mipmap level is 4-times smaller?\n        mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n    }\n\n    return imageBuffers;\n}\n\nfunction getImagePixelByteSize(glType: number, glFormat: number, glInternalFormat: number)\n{\n    let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n\n    if (glType !== 0)\n    {\n        // Uncompressed texture format\n        if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType])\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];\n        }\n        else\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];\n        }\n    }\n\n    if (imagePixelByteSize === undefined)\n    {\n        throw new Error('Unable to resolve the pixel format stored in the *.ktx file!');\n    }\n\n    return imagePixelByteSize;\n}\n\nfunction parseKTXHeader(dataView: DataView)\n{\n    const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;\n    const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);\n    const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);\n    const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n    const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);\n    const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;// \"pixelHeight = 0\" -> \"1\"\n    const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;// ^^\n    const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;// ^^\n    const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);\n    const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n    const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n\n    if (pixelHeight === 0 || pixelDepth !== 1)\n    {\n        throw new Error('Only 2D textures are supported');\n    }\n    if (numberOfFaces !== 1)\n    {\n        throw new Error('CubeTextures are not supported by KTXLoader yet!');\n    }\n    if (numberOfArrayElements !== 1)\n    {\n        throw new Error('WebGL does not support array textures');\n    }\n\n    return {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData\n    };\n}\n\n/**\n * Checks whether the arrayBuffer contains a valid *.ktx file.\n * @param dataView\n */\nfunction validate(dataView: DataView): boolean\n{\n    // NOTE: Do not optimize this into 3 32-bit integer comparison because the endianness\n    // of the data is not specified.\n    for (let i = 0; i < KTX.FILE_IDENTIFIER.length; i++)\n    {\n        if (dataView.getUint8(i) !== KTX.FILE_IDENTIFIER[i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}