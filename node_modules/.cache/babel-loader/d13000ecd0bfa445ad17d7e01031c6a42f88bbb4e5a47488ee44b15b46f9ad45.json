{"ast":null,"code":"import { BufferResource } from '../../../shared/buffer/BufferResource.mjs';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup.mjs';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers.mjs';\nimport { UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS } from './generateUniformsSyncTypes.mjs';\n\"use strict\";\nfunction generateUniformsSync(group, uniformData) {\n  const funcFragments = [\"\\n        var v = null;\\n        var cv = null;\\n        var cu = null;\\n        var t = 0;\\n        var gl = renderer.gl;\\n        var name = null;\\n    \"];\n  for (const i in group.uniforms) {\n    if (!uniformData[i]) {\n      if (group.uniforms[i] instanceof UniformGroup) {\n        if (group.uniforms[i].ubo) {\n          funcFragments.push(\"\\n                        renderer.shader.bindUniformBlock(uv.\".concat(i, \", \\\"\").concat(i, \"\\\");\\n                    \"));\n        } else {\n          funcFragments.push(\"\\n                        renderer.shader.updateUniformGroup(uv.\".concat(i, \");\\n                    \"));\n        }\n      } else if (group.uniforms[i] instanceof BufferResource) {\n        funcFragments.push(\"\\n                        renderer.shader.bindBufferResource(uv.\".concat(i, \", \\\"\").concat(i, \"\\\");\\n                    \"));\n      }\n      continue;\n    }\n    const uniform = group.uniformStructures[i];\n    let parsed = false;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const parser = uniformParsers[j];\n      if (uniform.type === parser.type && parser.test(uniform)) {\n        funcFragments.push(\"name = \\\"\".concat(i, \"\\\";\"), uniformParsers[j].uniform);\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n      const template = templateType[uniform.type].replace(\"location\", \"ud[\\\"\".concat(i, \"\\\"].location\"));\n      funcFragments.push(\"\\n            cu = ud[\\\"\".concat(i, \"\\\"];\\n            cv = cu.value;\\n            v = uv[\\\"\").concat(i, \"\\\"];\\n            \").concat(template, \";\"));\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", funcFragments.join(\"\\n\"));\n}\nexport { generateUniformsSync };","map":{"version":3,"names":["generateUniformsSync","group","uniformData","funcFragments","i","uniforms","UniformGroup","ubo","push","concat","BufferResource","uniform","uniformStructures","parsed","j","uniformParsers","length","parser","type","test","templateType","size","UNIFORM_TO_SINGLE_SETTERS","UNIFORM_TO_ARRAY_SETTERS","template","replace","Function","join"],"sources":["/home/user/Desktop/Projects/RoyalGames/royalgames-client/node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts"],"sourcesContent":["// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n"],"mappings":";;;;;AAagB,SAAAA,qBAAqBC,KAAA,EAAqBC,WAC1D;EACI,MAAMC,aAAA,GAAgB,8JAOrB;EAEU,WAAAC,CAAA,IAAKH,KAAA,CAAMI,QACtB;IACQ,KAACH,WAAY,CAAAE,CAAC,CAClB;MACI,IAAIH,KAAM,CAAAI,QAAA,CAASD,CAAC,aAAaE,YACjC;QACI,IAAKL,KAAM,CAAAI,QAAA,CAASD,CAAC,EAAmBG,GACxC;UACIJ,aAAA,CAAcK,IAAK,kEAAAC,MAAA,CACuBL,CAAC,UAAAK,MAAA,CAAML,CAAC,+BACjD;QAAA,CAGL;UACID,aAAA,CAAcK,IAAK,oEAAAC,MAAA,CACyBL,CAAC,6BAC5C;QAAA;MACL,CAEK,UAAAH,KAAA,CAAMI,QAAS,CAAAD,CAAC,aAAaM,cACtC;QACIP,aAAA,CAAcK,IAAK,oEAAAC,MAAA,CAC6BL,CAAC,UAAAK,MAAA,CAAML,CAAC,+BACnD;MAAA;MAGT;IAAA;IAGE,MAAAO,OAAA,GAAUV,KAAM,CAAAW,iBAAA,CAAkBR,CAAC;IAEzC,IAAIS,MAAS;IAEb,SAASC,CAAI,MAAGA,CAAI,GAAAC,cAAA,CAAeC,MAAA,EAAQF,CAC3C;MACU,MAAAG,MAAA,GAASF,cAAA,CAAeD,CAAC;MAE/B,IAAIH,OAAA,CAAQO,IAAS,KAAAD,MAAA,CAAOC,IAAA,IAAQD,MAAO,CAAAE,IAAA,CAAKR,OAAO,CACvD;QACIR,aAAA,CAAcK,IAAA,aAAAC,MAAA,CAAgBL,CAAC,UAAMW,cAAe,CAAAD,CAAC,EAAEH,OAAO;QACrDE,MAAA;QAET;MAAA;IACJ;IAGJ,IAAI,CAACA,MACL;MACI,MAAMO,YAAe,GAAAT,OAAA,CAAQU,IAAS,SAAIC,yBAA4B,GAAAC,wBAAA;MAEhE,MAAAC,QAAA,GAAWJ,YAAA,CAAaT,OAAQ,CAAAO,IAAI,EAAEO,OAAQ,qBAAAhB,MAAA,CAAmBL,CAAC,iBAAa;MAErFD,aAAA,CAAcK,IAAK,4BAAAC,MAAA,CACRL,CAAC,6DAAAK,MAAA,CAEFL,CAAC,wBAAAK,MAAA,CACTe,QAAQ,MAAG;IAAA;EACjB;EAUG,WAAIE,QAAA,CAAS,IAAM,QAAM,YAAY,UAAY,EAAAvB,aAAA,CAAcwB,IAAK,KAAI,CAAC;AACpF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}